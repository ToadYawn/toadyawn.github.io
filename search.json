[{"title":"MIMEpythonAPI入门","url":"/2020/05/03/MIMEpythonAPI入门/","content":"\nemail - 电子邮件与MIME处理包  \n\n1. 三主要组件，加上控制组件行为的组件  \n\n在 message 模块定义 EmailMessage 对象模型 是 树形结构  \n组件：parser 将字节流变为 EmailMessage 对象  \n    generator 将 EmailMessage 对象变为字节流 虽然支持文本字符流但是不推荐  \n控制组件： policy 通常在创建对象/复制/解析时用到 可在generator时改变 从硬盘中一般解析，然后以标准SMTP设置序列化后发送到服务器  \n\nemail包本来对应用隐藏RFC定义的一些细节，视之为unicode文本和二进制附件的结构树email对象。但是实际上经常必须知道MIME的content type和定义multipart的方式  \n\n2. 异常处理和 headerregistry/contentmanger 子组件\n\n\n## email.parser\n\n创建emailmeassage对象：1. 使用字典添加header,使用set_content()添加载荷  \n2.通过解析emailmessage成序列化表现形式  \n\n传入字节/字符串/文件对象，返回emailmessage实例的根  \n\n非MIME载荷的根对象是信息文本的字符串  \nMIME的根对象is_multipart()返回True，子部分用载荷操作方法比如get_body()iter_parts()和 walk()\n\n两个接口Parser API：内存中有整个信息文本，或者存在于文件中  \n增量FeedParserAPI：流读取 存在阻断等待\n\n通过实现Policy方法自定义版本来实现自己的解析器，连接EMAIL包和emailmessage类的逻辑  \n\nBytesFeedParser，导入email.feedparser模块  \nclass email.parser.BytesFeedParser(_factory=None, *, policy=policy.compat32)\n    feed(data) close()\n\nParser导入email.parser模块  \n模块下还有头解析器BytesHeaderParser和 HeaderParser  \nclass email.parser.BytesParser(_class=None, *, policy=policy.compat32)创建一个BytesParser实例  \n    parse(fp, headersonly=False)类文件对象，返回消息对象，fp中包含的字节必须格式化为RFC 5322 （或者，如果utf8是True，RFC 6532）样式的标头和标头延续行  \n    可选的headersonly用于在读取标题后是否停止解析  \n    parsebytes(bytes, headersonly=False)类字节对象，相当于先用BytesIO实例化再parse  \n    parsestr(text, headersonly=False)字符串对象  \nclass email.parser.BytesHeaderParser(_class=None, *, policy=policy.compat32) 和HeaderParser一样  \n完全一样BytesParser，只是headersonly 默认为True  \n    parse(fp, headersonly=False)  \n    parsestr(text, headersonly=False)  \n\nemail.message_from_bytes(s, _class=None, *, policy=policy.compat32)  \n类字节对象返回消息对象结构。等同于BytesParser().parsebytes(s)。可选的_class和 policy与BytesParser类构造函数一样解释。  \nemail.message_from_binary_file(fp, _class=None, *, policy=policy.compat32)  \nemail.message_from_string(s, _class=None, *, policy=policy.compat32)  \nemail.message_from_file(fp, _class=None, *, policy=policy.compat32)  \n\n大多数非多部分类型的消息都被解析为带有字符串有效负载的单个消息对象。这些对象将is_multipart()返回False，并且 iter_parts()将产生一个空列表  \n所有multipart的消息都将被解析为容器消息对象，并带有其有效负载的子消息对象列表  \nmessage / *的消息（例如 message / delivery-status和message / rfc822）也将被解析为包含长度为1的列表有效负载的容器对象  \n\n## email.message.EmailMessage\n\n### EmailMessage email.message模块导入的类  \n电子邮件包含标题和有效负载（也称为content）。标头是RFC 5322或RFC 6532样式字段名称和值  \n有效负载可以是简单的文本消息，也可以是二进制对象，也可以是子消息的结构化序列，每个子消息都具有自己的标头集和自己的有效负载。有效负载的后一种类型由具有MIME类型的消息（例如 multipart / *或 message / rfc822）指示  \n与实际字典不同的是，这些键有一个排序，并且可以有重复的键  \n\nclass email.message.EmailMessage(policy=default)  \n代替RFC强制\\r\\n使用，它使用Python标准\\n行尾  \nas_string(unixfrom=False, maxheaderlen=None, policy=None)返回整平为字符串的整个消息。当可选的 unixfrom为true时，信封头包含在返回的字符串中，指定的策略将传递给Generator \"7 bit clean\" when utf8 is False  \n\\_\\_str\\_\\_() 与as_string等同 utf8=True  \nas_bytes(unixfrom=False, policy=None)返回展平为字节对象的整个消息BytesGenerator  \n\\_\\_bytes\\_\\_()等同于as_bytes()  \nis_multipart()若消息负载是子消息对象的列表则返回True 返回True并不一定意味着“ msg.get_content_maintype（）=='multipart'”将返回True 例如EmailMessage 是 message/rfc822类型，is_multipart会返回True  \nset_unixfrom(unixfrom)将邮件的信封标头设置为unixfrom，它应该是一个字符串  \nget_unixfrom()返回邮件的信封头  \n\n### 访问消息头接口  \n\\_\\_len\\_\\_()返回头总数，包括重复项  \n\\_\\_contains\\_\\_(name)True如果消息对象具有名为name的字段。用于in例如：  \n```python\nif 'message-id' in myMessage:\nprint('Message-ID:', myMessage['message-id'])\n```  \n\n\\_\\_getitem\\_\\_(name) 返回头字段的值 若没有则返回None,若由多个字段则使用get_all()  \n\\_\\_setitem\\_\\_(name, val)向消息添加标头，其字段名称为name，值为val。该字段将附加到邮件现有标题的末尾。不能覆盖或删除任何现有的头名称相同。如果要确保新标题是消息中字段名称为name的唯一标题，请首先删除该字段，例如：  \n\n```python\ndel msg['subject']\nmsg['subject'] = 'Python roolz!'\n```\n\n\\_\\_delitem\\_\\_(name)从邮件标题中删除所有出现的名称为name的字段。如果标题字段中不存在命名字段，则不会引发异常。  \nkeys()返回所有消息标题字段名称的列表。  \nvalues()返回所有消息字段值的列表  \nitems()返回一个包含所有消息字段标题和值的2元组列表  \nget(name, failobj=None)与__getitem__等同，可选failobj在没有头字段时会返回  \n\n### 头字段相关方法  \nget_all(name, failobj=None)返回名为name的字段的所有值的列表。如果消息中没有这样的命名头，则返回failobj（默认为 None）  \nadd_header(_name, _value, **_params)与\\_\\_setitem\\_\\_() 类似_params是字典类型key=\"value\"，下划线转化为破折号(python中破折号非法) 值包含非ASCII字符，则可以通过将值指定为三个元组来显式地控制字符集和语言例如  (CHARSET, LANGUAGE, VALUE)\n```python\nmsg.add_header('Content-Disposition', 'attachment', filename='bud.gif')\nmsg.add_header('Content-Disposition', 'attachment',\n            filename=('iso-8859-1', '', 'Fußballer.ppt'))\n```\nreplace_header(_name, _value)\n替换在消息中找到的与_name匹配的第一个标头找不到匹配的头，引发 KeyError.  \nget_content_type()返回消息的内容类型，强制为小写形式 maintype / subtype。如果 消息中没有Content-Type头，则返回的值 get_default_type()。如果Content-Type标头无效，则返回text/plain  \nget_default_type()大多数消息的默认内容类型为text / plain，多部分/摘要容器的子部分的消息是message / rfc822  \nget_content_maintype()  \nget_content_subtype()  \n\nset_param(param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)将content-type设置param  \ndel_param(param, header='content-type', requote=True)  \n\nget_filename(failobj=None)得到Content-Disposition中filename的值，若没找到则找Content-Type中的name，都找不到 字符串将去掉引号  \nget_boundary(failobj=None)返回消息的Content-Type标头的boundary值 字符串将去掉引号  \nget_content_charset(failobj=None)返回消息的Content-Type标头的charset值强制转换为小写  \nget_charsets(failobj=None)返回包含消息中字符集名称的列表。如果消息是multipart，则列表将为有效负载中的每个子部分包含一个元素（字符串，表示子部分charset的Content-Type标头中的参数值），否则，它将是长度为1的列表  \nis_attachment() Cntent-Disposition值为attachment时返回True  \nget_content_disposition()返回 Content-Disposition 的值，如果没有则None\npreamble  \nepilogue  \ndefects  \n\n### 查询和处理消息的内容（有效负载）有关\n\nwalk() 迭代器。DFS遍历消息对象树在for循环中用作迭代器  \n```python\n>>> for part in msg.walk():\n...     print(part.get_content_type())\nmultipart/report\ntext/plain\nmessage/delivery-status\ntext/plain\ntext/plain\nmessage/rfc822\ntext/plain\n```\nwalk会继续访问is_multipart()返回true的对象\nis_multipart() returns True ,msg.get_content_maintype() == 'multipart' may return False (message/xxx)\n```python\n>>> from email.iterators import _structure\n>>> for part in msg.walk():\n...     print(part.get_content_maintype() == 'multipart',\n...           part.is_multipart())\nTrue True\nFalse False\nFalse True\nFalse False\nFalse False\nFalse True\nFalse False\n>>> _structure(msg)\nmultipart/report\n    text/plain\n    message/delivery-status\n        text/plain\n        text/plain\n    message/rfc822\n        text/plain\n```\nget_body(preferencelist=('related', 'html', 'plain'))返回最适合作为邮件“正文”的MIME部分\n参数是几个被视为正文的优先次序  \n遇到multipart/related时，检查start参数，如果子部分Content-ID匹配，则只考虑该子部分。否则考虑multipart/related的第一部分  \niter_attachments() 返回非正文（body）迭代器。跳过的每一个的第一次出现text/plain，text/html，multipart/related，或 multipart/alternative  \niter_parts()返回所有子部分迭代器 非multipart返回空  \nget_content(*args, content_manager=None, **kw)调用content_manager的get_content()方法，将self作为消息对象传递，并将其他任何参数或关键字作为附加参数传递。如果 未指定content_manager，则使用policy指定的content_manager  \nset_content(*args, content_manager=None, **kw)  \nmake_related(boundary=None)将非multipart消息转换为multipart/related消息，将所有现有的Content- Header和有效负载移动到的（新）第一部分multipart。如果边界指定，使用它作为在所述多部分的边界的字符串，否则离开边界到在需要时被自动创建（例如，当消息被序列）  \nmake_alternative(boundary=None)将非multipart或转换multipart/related为a multipart/alternative  \nmake_mixed(boundary=None)将non multipart，a multipart/related或a multipart-alternative转换为a multipart/mixed  \nadd_related（* args，content_manager = None，** kw ）如果消息为multipart/related，则创建一个新的消息对象，将所有参数传递给它的set_content()方法，然后attach()传递给multipart。如果该消息不是multipart，调用make_related()之后在进行上述操作  \nadd_alternative(*args, content_manager=None, **kw)  \nadd_attachment(*args, content_manager=None, **kw)  \nclear()删除有效负载和所有标头  \nclear_content()删除有效负载和所有Content-标头，并保留所有其他标头并保持其原始顺序。  \n\n## email.message.Message: 使用compat32API 表示电子邮件\nclass email.message.Message(policy=compat32)\n\n\n## email.generator: Generating MIME documents\n写一个.eml文件\n```python\nimport os\nfrom email import generator\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nactive_dir = 'c:\\\\'\n\ncwd = os.getcwd()\noutfile_name = os.path.join(cwd, 'message.eml')\nclass Gen_Emails(object):\n    def __init__(self):\n        self.EmailGen()\n\n    def EmailGen(self):\n        sender = 'sender'\n        recepiant = 'recipiant'\n        subject = 'subject'\n\n        msg = MIMEMultipart('alternative')\n        msg['Subject'] = subject\n        msg['From'] = sender\n        msg['To'] = recepiant\n\n\n        html = \"\"\"\\\n        <html>\n            <head></head>\n            <body>\n                <p> hello world </p>\n            </body>\n        </html>\n        \"\"\"\n        part = MIMEText(html, 'html')\n\n        msg.attach(part)\n\n        self.SaveToFile(msg)\n\n    def SaveToFile(self,msg):\n        with open(outfile_name, 'w') as outfile:\n            gen = generator.Generator(outfile)\n            gen.flatten(msg)\n```\n## email.policy: Policy Objects\n\nPolicy实例是不可变的，但是可以将其克隆，接受与类构造函数相同的关键字参数，并返回一个新 Policy实例，该实例是原始实例的副本，但指定的属性值已更改  \n\n## email.headerregistry\n## email.contentmanager\nclass email.contentmanager.ContentManager  \nas_string(unixfrom=False, maxheaderlen=0, policy=None)  \n\\_\\_str\\_\\_()\nas_bytes(unixfrom=False, policy=None)  \n\\_\\_bytes\\_\\_()  \nis_multipart()  \nset_unixfrom(unixfrom)  \nget_unixfrom()  \nattach(payload) EmailMessage中set_content()等同  \nget_payload(i=None, decode=False)返回当前二进制/字符串有效负载。可选参数i，将返回有效载荷的第i个元素从0开始 decode是True时，负载不是mukltipart,Content-Transfer-Encoding是quoted-printable 或者 base64，则解码。decode是False时,主体会返回字符串。 EmailMessage中get_content() 和 iter_parts().  \nset_payload(payload, charset=None)  \nset_charset(charset)  \nget_charset()  \n\\_\\_len\\_\\_()  \n\\_\\_contains\\\\_(name)  \n\\_\\_getitem\\_\\_(name)\n\\_\\_delitem\\_\\_(name)  \nkeys()  \nvalues()  \nitems()  \nget(name, failobj=None)  \n···其他都与EmailMessage相同\n\n## 示例\n```python\nfrom email.parser import BytesParser, Parser\nfrom email.policy import default\n\n# If the e-mail headers are in a file, uncomment these two lines:\n# with open(messagefile, 'rb') as fp:\n#     headers = BytesParser(policy=default).parse(fp)\n\n#  Or for parsing headers in a string (this is an uncommon operation), use:\nheaders = Parser(policy=default).parsestr(\n        'From: Foo Bar <user@example.com>\\n'\n        'To: <someone_else@example.com>\\n'\n        'Subject: Test message\\n'\n        '\\n'\n        'Body would go here\\n')\n\n#  Now the header items can be accessed as a dictionary:\nprint('To: {}'.format(headers['to']))\nprint('From: {}'.format(headers['from']))\nprint('Subject: {}'.format(headers['subject']))\n\n# You can also access the parts of the addresses:\nprint('Recipient username: {}'.format(headers['to'].addresses[0].username))\nprint('Sender name: {}'.format(headers['from'].addresses[0].display_name))\n\n```\n以下是如何发送包含可能在目录中的一系列家庭照片的MIME消息示例：\n```python\n# Import smtplib for the actual sending function\nimport smtplib\n\n# And imghdr to find the types of our images\nimport imghdr\n\n# Here are the email package modules we'll need\nfrom email.message import EmailMessage\n\n# Create the container email message.\nmsg = EmailMessage()\nmsg['Subject'] = 'Our family reunion'\n# me == the sender's email address\n# family = the list of all recipients' email addresses\nmsg['From'] = me\nmsg['To'] = ', '.join(family)\nmsg.preamble = 'You will not see this in a MIME-aware mail reader.\\n'\n\n# Open the files in binary mode.  Use imghdr to figure out the\n# MIME subtype for each specific image.\nfor file in pngfiles:\n    with open(file, 'rb') as fp:\n        img_data = fp.read()\n    msg.add_attachment(img_data, maintype='image',\n                                 subtype=imghdr.what(None, img_data))\n\n# Send the email via our own SMTP server.\nwith smtplib.SMTP('localhost') as s:\n    s.send_message(msg)\n\n```\n\n以下是如何将上述MIME消息解压缩到文件目录中的示例：\n```python\n#!/usr/bin/env python3\n\n\"\"\"Unpack a MIME message into a directory of files.\"\"\"\n\nimport os\nimport email\nimport mimetypes\n\nfrom email.policy import default\n\nfrom argparse import ArgumentParser\n\n\ndef main():\n    parser = ArgumentParser(description=\"\"\"\\\nUnpack a MIME message into a directory of files.\n\"\"\")\n    parser.add_argument('-d', '--directory', required=True,\n                        help=\"\"\"Unpack the MIME message into the named\n                        directory, which will be created if it doesn't already\n                        exist.\"\"\")\n    parser.add_argument('msgfile')\n    args = parser.parse_args()\n\n    with open(args.msgfile, 'rb') as fp:\n        msg = email.message_from_binary_file(fp, policy=default)\n\n    try:\n        os.mkdir(args.directory)\n    except FileExistsError:\n        pass\n\n    counter = 1\n    for part in msg.walk():\n        # multipart/* are just containers\n        if part.get_content_maintype() == 'multipart':\n            continue\n        # Applications should really sanitize the given filename so that an\n        # email message can't be used to overwrite important files\n        filename = part.get_filename()\n        if not filename:\n            ext = mimetypes.guess_extension(part.get_content_type())\n            if not ext:\n                # Use a generic bag-of-bits extension\n                ext = '.bin'\n            filename = f'part-{counter:03d}{ext}'\n        counter += 1\n        with open(os.path.join(args.directory, filename), 'wb') as fp:\n            fp.write(part.get_payload(decode=True))\n\n\nif __name__ == '__main__':\n    main()\n```\n\n在HTML中插入图片发送：\n```python\n#!/usr/bin/env python3\n\nimport smtplib\n\nfrom email.message import EmailMessage\nfrom email.headerregistry import Address\nfrom email.utils import make_msgid\n\n# Create the base text message.\nmsg = EmailMessage()\nmsg['Subject'] = \"Ayons asperges pour le déjeuner\"\nmsg['From'] = Address(\"Pepé Le Pew\", \"pepe\", \"example.com\")\nmsg['To'] = (Address(\"Penelope Pussycat\", \"penelope\", \"example.com\"),\n             Address(\"Fabrette Pussycat\", \"fabrette\", \"example.com\"))\nmsg.set_content(\"\"\"\\\nSalut!\n\nCela ressemble à un excellent recipie[1] déjeuner.\n\n[1] http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718\n\n--Pepé\n\"\"\")\n\n# Add the html version.  This converts the message into a multipart/alternative\n# container, with the original text message as the first part and the new html\n# message as the second part.\nasparagus_cid = make_msgid() #生成Message-ID\nmsg.add_alternative(\"\"\"\\\n<html>\n  <head></head>\n  <body>\n    <p>Salut!</p>\n    <p>Cela ressemble à un excellent\n        <a href=\"http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718\">\n            recipie\n        </a> déjeuner.\n    </p>\n    <img src=\"cid:{asparagus_cid}\" />\n  </body>\n</html>\n\"\"\".format(asparagus_cid=asparagus_cid[1:-1]), subtype='html')\n# note that we needed to peel the <> off the msgid for use in the html.\n\n# Now add the related image to the html part.\nwith open(\"roasted-asparagus.jpg\", 'rb') as img:\n    msg.get_payload()[1].add_related(img.read(), 'image', 'jpeg',\n                                     cid=asparagus_cid)\n\n# Make a local copy of what we are going to send.\nwith open('outgoing.msg', 'wb') as f:\n    f.write(bytes(msg))\n\n# Send the message via local SMTP server.\nwith smtplib.SMTP('localhost') as s:\n    s.send_message(msg)\n```\n\n处理html中带有附件的邮件文件（xx.msg）：\n```python\nimport os\nimport sys\nimport tempfile\nimport mimetypes\nimport webbrowser\n\n# Import the email modules we'll need\nfrom email import policy\nfrom email.parser import BytesParser\n\n# An imaginary module that would make this work and be safe.\nfrom imaginary import magic_html_parser\n\n# In a real program you'd get the filename from the arguments.\nwith open('outgoing.msg', 'rb') as fp:\n    msg = BytesParser(policy=policy.default).parse(fp)\n\n# Now the header items can be accessed as a dictionary, and any non-ASCII will\n# be converted to unicode:\nprint('To:', msg['to'])\nprint('From:', msg['from'])\nprint('Subject:', msg['subject'])\n\n# If we want to print a preview of the message content, we can extract whatever\n# the least formatted payload is and print the first three lines.  Of course,\n# if the message has no plain text part printing the first three lines of html\n# is probably useless, but this is just a conceptual example.\nsimplest = msg.get_body(preferencelist=('plain', 'html'))\nprint()\nprint(''.join(simplest.get_content().splitlines(keepends=True)[:3]))\n\nans = input(\"View full message?\")\nif ans.lower()[0] == 'n':\n    sys.exit()\n\n# We can extract the richest alternative in order to display it:\nrichest = msg.get_body()\npartfiles = {}\nif richest['content-type'].maintype == 'text':\n    if richest['content-type'].subtype == 'plain':\n        for line in richest.get_content().splitlines():\n            print(line)\n        sys.exit()\n    elif richest['content-type'].subtype == 'html':\n        body = richest\n    else:\n        print(\"Don't know how to display {}\".format(richest.get_content_type()))\n        sys.exit()\nelif richest['content-type'].content_type == 'multipart/related':\n    body = richest.get_body(preferencelist=('html'))\n    for part in richest.iter_attachments():\n        fn = part.get_filename()\n        if fn:\n            extension = os.path.splitext(part.get_filename())[1]\n        else:\n            extension = mimetypes.guess_extension(part.get_content_type())\n        with tempfile.NamedTemporaryFile(suffix=extension, delete=False) as f:\n            f.write(part.get_content())\n            # again strip the <> to go from email form of cid to html form.\n            partfiles[part['content-id'][1:-1]] = f.name\nelse:\n    print(\"Don't know how to display {}\".format(richest.get_content_type()))\n    sys.exit()\nwith tempfile.NamedTemporaryFile(mode='w', delete=False) as f:\n    # The magic_html_parser has to rewrite the href=\"cid:....\" attributes to\n    # point to the filenames in partfiles.  It also has to do a safety-sanitize\n    # of the html.  It could be written using html.parser.\n    f.write(magic_html_parser(body.get_content(), partfiles))\nwebbrowser.open(f.name)\nos.remove(f.name)\nfor fn in partfiles.values():\n    os.remove(fn)\n\n# Of course, there are lots of email messages that could break this simple\n# minded program, but it will handle the most common ones.\n```\nTo: Penelope Pussycat <penelope@example.com>, Fabrette Pussycat <fabrette@example.com>\nFrom: Pepé Le Pew <pepe@example.com>\nSubject: Ayons asperges pour le déjeuner\n\nSalut!\n\nCela ressemble à un excellent recipie[1] déjeuner.","tags":["python"]},{"title":"dpkt入门","url":"/2020/04/28/dpkt入门/","content":"\n## 模块及接口\n\n### dpkt.Packet\n\n\n```python\n\nattr:\n\n1. __hdr__ = ( ('字段','占位',值) )\n    # 占位: H/I/B short/int/ 16b/32b/4b\n    # (name, structfmt, default) tuples\n        class Foo(Packet):\n            __hdr__ = (('foo', 'I', 1), ('bar', 'H', 2), ('baz', '4s', 'quux'))\n        >>> foo = Foo(bar=3)\n        >>> foo\n        Foo(bar=3)\n        >>> str(foo)\n        '\\x00\\x00\\x00\\x01\\x00\\x03quux'\n        >>> foo.bar\n        3\n        >>> foo.baz\n        'quux'\n        >>> foo.foo = 7\n        >>> foo.baz = 'whee'\n        >>> foo\n        Foo(baz='whee', foo=7, bar=3)\n        >>> Foo('hello, world!')\n        Foo(baz=' wor', foo=1751477356L, bar=28460, data='ld!')\n2. __byte_order__ 默认'>'\n\nmethod:\n\n1. __init__ (buf,keyword[field=val,...])\n    # 可以传入待解包的报文，一旦传入，则程序会自动调用unpack()函数进行解包 struct.unpack(self.__hdr_fmt__, buf[:self.__hdr_len__]))    self.data = buf[self.__hdr_len__:] \n    # keyword：设置__hdr__的相关域的值\n\n    >>> struct.unpack('>IH', b'\\xf0\\xf0\\xf0\\xf0\\x80\\x80')\n    (4042322160, 32896)\n    >>> struct.pack(\"ihb\", 1, 2, 3)\n    '\\x01\\x00\\x00\\x00\\x02\\x00\\x03'\n    3、继承了__str__()函数，使得调用str()时，会进行如下操作：\n    return self.pack_hdr() + str(self.data)\n\n2. int __len__  len(packet)\n\n3. self __iter__ 可迭代\n\n4. __getitem__ 按下标取 https://www.jianshu.com/p/d5783fb60d29\n\n5. string __repr__  s = packet\n\n6. __str__ str(self.__bytes__())\n\n7. __bytes__ self.pack_hdr() + bytes(self.data)\n\n8. 报文头字符串 bytes pack_hdr(self)\n\n调用_pack_hdr = partial(struct.pack, self.__hdr_fmt__),\n参数为报文头关键字self._pack_hdr(*[getattr(self, k) for k in self.__hdr_fields__]) \n# functools.partial 偏函数，添加函数默认参数值partial(原函数,参数)\n\n9. 全包转化为字节 bytes pack(self) = bytes(self)\n\n10. 从字节流转化为Packet类 Packet unpack(self,buf) dpkt.Packet.unpack(self,buf)\n\n11. 从字节流转化为16进制字符串 string hexdump(buf, length=16)\n\n12. 计算buf的检验和 int in_cksum(buf)\n```\n\n\n### pcap\n\n```python\n# 文件头与包头类\n# pcap文件头类 bytes:大端二进制流/pcap文件\nfh FileHdr(bytes) # 转化bytes为filehdr类\n    # 成员 见pcap文件定义 \n    __hdr__:\n        fh.magic\n        fh.v_major\n        fh.v_minor\n        fh.thiszone\n        fh.sigfigs\n        fh.snaplen\n        fh.linktype\nLEFileHdr\n    同FileHdr\n    __byte_order__\n\n>>> be = b'\\xa1\\xb2\\xc3\\xd4\\x00\\x02\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x60\\x00\\x00\\x00\\x01'\n>>> le = b'\\xd4\\xc3\\xb2\\xa1\\x02\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x60\\x00\\x00\\x00\\x01\\x00\\x00\\x00'\n>>> befh = FileHdr(be)\n>>> lefh = LEFileHdr(le)\nassert (befh.linktype == lefh.linktype)\n\n# packet头类\nPktHdr \n    __hdr__:\n        tv_sec\n        tv_usec\n        caplen\n        len\nLEPktHdr\n    同PktHdr\n    __byte_order__\n>>> data = (  # full libpcap file with one packet\n        b'\\xd4\\xc3\\xb2\\xa1\\x02\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x01\\x00\\x00\\x00'\n        b'\\xb2\\x67\\x4a\\x42\\xae\\x91\\x07\\x00\\x46\\x00\\x00\\x00\\x46\\x00\\x00\\x00\\x00\\xc0\\x9f\\x32\\x41\\x8c\\x00\\xe0'\n        b'\\x18\\xb1\\x0c\\xad\\x08\\x00\\x45\\x00\\x00\\x38\\x00\\x00\\x40\\x00\\x40\\x11\\x65\\x47\\xc0\\xa8\\xaa\\x08\\xc0\\xa8'\n        b'\\xaa\\x14\\x80\\x1b\\x00\\x35\\x00\\x24\\x85\\xed'\n    )\n\n>>> fobj = BytesIO(data)\n>>> reader = dpkt.pcap.Reader(fobj)\n>>> assert reader.name == '<BytesIO>'\n>>> buf1 = next(iter(reader))\n>>> assert buf1 == data[FileHdr.__hdr_len__ + PktHdr.__hdr_len__:]# 这两个长度是固定的\nfobj.seek(0) file指针偏移\nreader = Reader(fobj)\nassert reader.dispatch(0, lambda ts, pkt: None) == 1\n\n\n__le = sys.byteorder == 'little'\n# Writer 和 Reader\nWriter(fileobj,snaplen=1500,linktype=DLT_EN10MB, nano=False)\n    __f\n    _precision\n    根据__le使用LEFileHdr/FileHdr生成fh,_PktHdr\n    由_PktHdr生成bytes类 _pack_hdr\n\n    writepkt(pkt,ts=None) 调用writepkt_time pkt (bytes) ts (float)\n    >>> ts, pkt = 1454725786.526401, b'foooo'\n    >>> writer.writepk(pkt, ts)\n    writepkt_time(pkt,ts) 生成头，并和pkt一起写入self.__f\n    writepkts(pkts) pkts: iterable containing (ts, pkt)\n    >>> pkts = [\n        (1454725786.526401, b\"fooo\"),\n        (1454725787.526401, b\"barr\"),\n        (3243204320.093211, b\"grill\"),\n        (1454725789.526401, b\"lol\"),\n    ]\n    >>> writer.writepkts(pkts)\n\nReader(fileobj)\n    name\n    __f\n    buf = self.__f.read(FileHdr.__hdr_len__)\n    self.__fh = FileHdr(buf) #__attr 是特殊属性 私有且不能访问\n    self.__ph = PktHdr\n    self._divisor = 1E6 if self.__fh.magic in (TCPDUMP_MAGIC, PMUDPCT_MAGIC) else Decimal('1E9')\n    self.snaplen = self.__fh.snaplen\n    self.filter = ''\n    self.__iter = iter(self)\n    @property\n    fd(self) return self.__f.fileno()\n    fileno(self) return self.fd\n    datalink(self) return self.__fh.linktype\n    readpkts(self) return list(self)\n    __next__(self) return next(self.__iter)\n    dispatch(self, cnt, callback, *args) cnt处理packet数 已处理数\n    # Reader返回的是packet元组(ts,buf)\n\n```\n\n### ip\n\n```python\n\nIP(dpkt.Packet)\n    __hdr__\n        _v_hl B \n        tos B \n        len H\n        id H\n        off H\n        ttl B\n        p B\n        sum H\n        src 4s\n        dst 4s\n    _protosw 字典\n    opts\n\n    @property\n    v(self) return self._v_hl >> 4\n    @v.setter\n    v(self, v) self._v_hl = (v << 4) | (self._v_hl & 0xf)\n    @property\n    hl(self) return self._v_hl & 0xf\n    @hl.setter\n    hl(self, hl) self._v_hl = (self._v_hl & 0xf0) | hl\n    @property\n    rf(self) return (self.off >> 15) & 0x1 DF010\n    @rf.setter\n    rf(self, rf) self.off = (self.off & ~IP_RF) | (rf << 15) #~x = -x-1\n    @property\n    df(self) return (self.off >> 14) & 0x1\n    @df.setter\n    df(self, df) self.off = (self.off & ~IP_DF) | (df << 14)\n    @property\n    mf(self) return (self.off >> 13) & 0x1\n    @mf.setter\n    mf(self, mf) self.off = (self.off & ~IP_MF) | (mf << 13)\n    @property\n    offset(self) return (self.off & IP_OFFMASK) << 3 # 单位是bit 正好偏移3位\n    @offset.setter\n    offset(self, offset) self.off = (self.off & ~IP_OFFMASK) | (offset >> 3)\n\n    __len__ return self.__hdr_len__ + len(self.opts) + len(self.data)\n    __bytes__ return self.pack_hdr() + bytes(self.opts) + bytes(self.data)\n\n    unpack(self,buf) dpkt.Packet.unpack(self, buf) self.opts self.data\n\n    @classmethod set_proto(cls, p, pktclass) cls._protosw[p] = pktclass 类的属性方法\n    @classmethod get_proto(cls, p) return cls._protosw[p]\n\n    >>> s = b'E\\x00\\x00\"\\x00\\x00\\x00\\x00@\\x11r\\xc0\\x01\\x02\\x03\\x04\\x01\\x02\\x03\\x04\\x00o\\x00\\xde\\x00\\x0e\\xbf5foobar'\n\n    用字段来初始化\n    >>> ip = IP(id=0, src=b'\\x01\\x02\\x03\\x04', dst=b'\\x01\\x02\\x03\\x04', p=17)\n    >>> u = udp.UDP(sport=111, dport=222)\n    >>> u.data = b'foobar'\n    >>> u.ulen += len(u.data)\n    >>> ip.data = u\n    >>> ip.len += len(u)\n    >>> assert (bytes(ip) == s)\n    >>> assert (ip.v == 4)\n    >>> assert (ip.hl == 5)\n    直接用bytes来初始化\n    >>> ip = IP(s)\n    >>> assert (bytes(ip) == s)\n    >>> assert (ip.udp.data == b'foobar')\n    生成对应dict\n    >>> d = dict(ip)\n    >>> assert (d['src'] == b'\\x01\\x02\\x03\\x04')\n    >>> assert (d['dst'] == b'\\x01\\x02\\x03\\x04')\n    >>> assert (d['id'] == 0)\n    >>> assert (d['p'] == 17)\n    检查bytes是否语法错误(通常是E/45)\n    >>> s = b'BB\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd0\\x00\\xec\\xbc\\xa5\\x00\\x00\\x00\\x03\\x80\\x00\\x00\\xd0\\x01\\xf2\\xac\\xa5\"0\\x01\\x00\\x14\\x00\\x02\\x00\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    >>> try:\n    >>>     IP(s)\n    >>> except dpkt.UnpackError:\n    >>>     pass\n\n    >>> d = b'X' * 2048\n    >>> s = b'E\\x00\\x00\\x004\\xce@\\x00\\x80\\x06\\x00\\x00\\x7f\\x00\\x00\\x01\\x7f\\x00\\x00\\x01\\xccN\\x0c8`\\xff\\xc6N_\\x8a\\x12\\x98P\\x18@):\\xa3\\x00\\x00' + d\n    >>> ip = IP(s)\n    >>> assert (isinstance(ip.data, tcp.TCP))\n    >>> assert (ip.tcp.data == d)\n\n    总长度指定无效\n    >>> ip1 = IP(data = b\"Hello world!\")\n    >>> ip2 = IP(data = b\"Hello world!\", len = 0)\n    >>> ip3 = IP(bytes(ip1))\n    >>> ip4 = IP(bytes(ip2))\n    >>> assert (bytes(ip1) == bytes(ip3))\n    >>> assert (bytes(ip1) == b'E\\x00\\x00 \\x00\\x00\\x00\\x00@\\x00z\\xdf\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Hello world!')\n    >>> assert (bytes(ip2) == bytes(ip4))\n    >>> assert (bytes(ip2) == b'E\\x00\\x00 \\x00\\x00\\x00\\x00@\\x00z\\xdf\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Hello world!')\n\n    .ip .tcp可生成对应上层对象\n    >>> from . import ethernet\n    >>> s = b\"\\x00\\x23\\x20\\xd4\\x2a\\x8c\\x00\\x23\\x20\\xd4\\x2a\\x8c\\x08\\x00\\x45\\x00\\x00\\x54\\x00\\x00\\x40\\x00\\x40\\x01\\x25\\x8d\\x0a\\x00\\x00\\x8f\\x0a\\x00\\x00\\x8e\\x08\\x00\\x2e\\xa0\\x01\\xff\\x23\\x73\\x20\\x48\\x4a\\x4d\\x00\\x00\\x00\\x00\\x78\\x85\\x02\\x00\\x00\\x00\\x00\\x00\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\"\n    >>> ip = ethernet.Ethernet(s).ip\n    >>> assert (ip.rf == 0)\n    >>> assert (ip.df == 1)\n    >>> assert (ip.mf == 0)\n    >>> assert (ip.offset == 0)\n    修改分片及偏移\n    >>> ip.rf = 1\n    >>> ip.df = 0\n    >>> ip.mf = 1\n    >>> ip.offset = 1480\n    >>> assert (ip.rf == 1)\n    >>> assert (ip.df == 0)\n    >>> assert (ip.mf == 1)\n    >>> assert (ip.offset == 1480)\n\n```\n\n### tcp\n```python\nTCP(dpkt.Packet)\n    __hdr__\n        sport\n        dport\n        seq\n        ack\n        _off # 访问时 self._off为80 self.off为5\n        flags\n        win\n        sum\n        urp\n    opts\n\n    @property\n    off(self): return self._off >> 4 # 单位是 4B  0:15 * 4 B 正好保留字段也是4位(在_off字段)+2位(在flags字段)\n    @off.setter\n    off(self, off) self._off = (off << 4) | (self._off & 0xf)\n\n    __len__(self) self.__hdr_len__ + len(self.opts) + len(self.data)\n\n    __bytes__(self) return self.pack_hdr() + bytes(self.opts) + bytes(self.data)\n\n    unpack(self, buf) dpkt.Packet.unpack(self, buf)\n        ol = ((self._off >> 4) << 2) - self.__hdr_len__ # optional length\n        if ol < 0:\n            raise dpkt.UnpackError('invalid header length')\n        self.opts = buf[self.__hdr_len__:self.__hdr_len__ + ol]\n        self.data = buf[self.__hdr_len__ + ol:]\n    \n    opts[(option,data),...] parse_opts(buf) # 将tcp可选字段buffer转化为(option,data)元组\n\n    >>> buf = b'\\x02\\x04\\x23\\x00\\x01\\x01\\x04\\x02'\n    >>> opts = parse_opts(buf)\n    >>> assert opts == [\n        (TCP_OPT_MSS, b'\\x23\\x00'),\n        (TCP_OPT_NOP, b''),\n        (TCP_OPT_NOP, b''),\n        (TCP_OPT_SACKOK, b'')\n        ]\n    >>> buf = b'\\x01\\x01\\x05\\x0a\\x37\\xf8\\x19\\x70\\x37\\xf8\\x29\\x78'\n    >>> opts = parse_opts(buf)\n    >>> assert opts == [\n        (TCP_OPT_NOP, b''),\n        (TCP_OPT_NOP, b''),\n        (TCP_OPT_SACK, b'\\x37\\xf8\\x19\\x70\\x37\\xf8\\x29\\x78')\n        ]\n    >>> buf = b'\\xff'\n    >>> opts = parse_opts(buf)\n    >>> assert opts == [None]\n\n    # 访问TCP偏移值\n    >>> tcpheader = TCP(b'\\x01\\xbb\\xc0\\xd7\\xb6\\x56\\xa8\\xb9\\xd1\\xac\\xaa\\xb1\\x50\\x18\\x40\\x00\\x56\\xf8\\x00\\x00')\n    >>> assert tcpheader.off == 5\n```","tags":["python, dpkt, pcap"]},{"title":"Hello World","url":"/2020/04/23/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"DigestWorldHistory004古代两河流域文明（2）","url":"/2020/02/07/history005/","content":"\n奔腾的幼发拉底河和底格里斯河见证了苏美尔人和巴比伦人跌宕起伏的经历，现在他们将继续见证两河流域文明在**亚述人**手中如何发扬光大。  \n亚述人统治两河流域时期，发端于**西部巴勒斯坦地区的犹太文明**以及发端于**东部伊朗高原的波斯文明**，摆脱长期在两河流域文明笼罩下的阴影，开始形成独立的犹太文明和波斯文明。现在，让我们一起来继续揭开两河流域文明神秘的面纱。  \n\n## 亚述人统治西亚\n\n亚述人的性格骠悍、凶猛，战争是每个亚述男性终生的职业。亚述人的统治经历了古王国、中王国和帝国统治三个时期。  \n在每个时期，几乎每个国王统治生活中最重要的事业就是对外发动战争、对内平定叛乱。除此之外，国王的最大嗜好可能就是狩猎。  \n在亚述地区的考古发掘中，特别是在亚述帝国时期遗址中，发现了大量绘有狩猎场面的浮雕，有猎牛、猎狮。看着那些栩栩如生的画面，我们甚至能听到动物的哀呜声、如雷的战鼓声、厮杀声以及庆功的杯盏叮当声。**传说，亚述帝国的阿述尔巴尼拔王，一人就曾经杀死过4500头狮子。**  \n1843年，法国人博塔在今伊拉克北部尼尼微发现了宏伟的亚述宫殿。  \n\n>博塔是摩苏尔的法国领事，他对当地传说中古迹的事非常感兴趣，法国人在博塔的启发下迅速意识到，伊拉克北部的古迹非同寻常，因为《圣经》中提到了亚述人，亚述人对犹大王国的征服，还有亚述人对诸如拉西什等地的围困等，这些也在《圣经》及苏美尔文献中提到过。博塔在萨尔贡建立的首都进行发掘，发现了大量的浮雕。尼尼微距今伊拉克北部城市摩苏儿不远，它的历史可追溯到公元前5000年，是亚述帝国的首都之一，19世纪的发掘工作使尼尼微闻名遐迩。在所谓的辛那赫里布西南王宫里发现了一些惊人的宫殿建筑以及一些精彩绝伦的浮雕，在尼尼微的考古发掘是亚述文明遗址中发掘较早的一个，是除《圣经》考古以外第一次发掘亚述文明的遗址。  \n澳大利亚悉尼大学博士丹·波茨  \n\n他的发现轰动了世界，向世界展示了亚述文明真正的辉煌和灿烂。**尼尼微，亚述帝国多数王的首都**，位于底格里期河和大扎布河的交汇处。公元前12世纪末时，尼尼微就已经是一座大城。亚述王萨尔贡二世的儿子**辛那赫里布**在尼尼微修建了运河、导水管和一座宏伟的宫殿。尼尼微城成为当时两河流域地区的中心，它人口众多，据记载，仅儿童就有几万人。  \n在犹太人眼里，亚述帝国的国王几乎个个都以残暴无情著称，因此他们把亚述帝国的首都称为狮子的巢穴，认为这里是嗜血的城市，并且下了最恶毒的诅咒。公元前612年5月尼尼微城陷落了。亚述王为他们的残暴无情付出了代价，但是他们也为保存古代两河流域文明作出了前人无可比拟的贡献。  \n**阿述尔巴尼拔**是其中最杰出的一位，他年轻的时候就精通数学和书吏技术，后来他在首都尼尼微筹建**世界上第一个规范的图书馆**。  \n国王下令全国上缴各个时期各类泥板图书。现存的三万多块泥板，大多是图书管理员复制的，泥板文书几乎涵盖了古代两河流域文明的所有精华，包括文学作品、法律条文、合同契约、宗教祭文等等。图书馆的书吏还对馆藏图书进行编目，这成为世界上最早的分类信息目录。**亚述帝国灭亡了，古代两河流域文明失去了文明发展的独立载体，而两河流域文明的精髓却在犹太文明和波斯文明中保存下来，并继续影响着世界文明。**  \n\n## 犹太文明\n\n大约4000年前，亚伯拉罕离开乌尔城来到迦南，犹太人的历史从此展开。在这期间，**一个自称是亚伯拉罕的孙子的人叫雅各与一位天使角斗了一天一夜之后，得到了以色列的称号**，意思是**神的勇士**，这就是以色列的由来。  \n300年后，一批辗转流落至埃及的犹太人在摩西的率领下，返回巴勒斯坦地区，建立了自己的统一国家。公元前1000年左右，犹太古代历史进入最辉煌的时期——**大卫王统治时期**，正是在这个时期，他开始**兴建耶路撒冷城**。在大卫王的儿子**所罗门时期，耶路撒冷即和平之城终于建成了**。后来对犹太人影响极其深远的圣殿也是在这个时期建成的。今天圣殿仅剩一面哭墙，但是它是犹太人的精神支柱。  \n公元前597年3月16日，耶路撒冷被新巴比伦王**尼布贾尼撒**攻陷，大批犹太人被掳回巴比伦，这就是**巴比伦之囚**。巴比伦之囚仅仅是犹太人多舛命运的开始，在以后的几千年里，犹太人先后数次遭受外族的迫害和驱逐，丧失了家园，流散在世界各地。在俄罗斯、捷克波兰德国、美国、甚至在中国都有犹太人的身影。  \n令人回味的是，犹太人是让两河流域文明流传后世的主要功臣。  \n基督教经典《旧约圣经》中记载的上帝造人故事、洪水的故事、伊甸园的故事等等都源于犹太教和经典，而这些都可以在古代两河流域文明中找到源头。  \n古代东方的许多传统，经犹太人之手留存下来，并至今影响着西方人的生活，其中最主要的就是一神论思想，犹太宗教对基督教和伊斯兰教的形成也产生过重大影响。  \n\n## 波斯文明\n\n被囚在巴比伦的犹太人终于可以回家了，**他们的救世主就是波斯帝国的缔造者——居鲁士**。与阿卡德王朝的开国君主萨尔贡一样，居鲁士也为自己编造了几乎如出一辙的传奇身世。他统治的30年间，他确定了波斯帝国的基本版图，其子**冈比西斯**更征服了整个两河流域地区和埃及，第一次建立了一个地跨西亚北非的强大帝国。  \n居鲁士的**孙辈大流士**，使波斯帝国的统治更加完善，他建立发达的道路交通系统，建立赋税制度。公元前520年，他建造了辉煌的**都城波塞波利斯**。波塞波利斯的建筑样式和风格承袭了巴比伦和亚述城市建筑的特色。  \n\n>波塞波利斯的地位非常重要，因为我们可以看到阿赫美尼德国王，在当地留下的墓穴，我们还可以在同一个地方，看到不同国家艺术的混合这是为了表现这一帝国的国际性，表明它是世界上第一个国际性国家。  \n伊朗国家博物馆夏洛克·拉真诸  \n\n波塞波利斯王宫奢华、豪放的建筑风格，充分体现了当时波斯帝国的强大与富庶，其中以两块浮雕最具代表意义。  \n\n>一个是薛西昕的浮雕，在这之前许多专家认为这是大流士的浮雕，浮雕表现的是朝觐场面，它原来摆放在波塞波利斯的阿卡德觐见厅楼梯中间，但由于一些我们不知道的原因，后来的波斯国王把它从楼梯中间拿走，放到了波塞波利斯的珍宝厅，此外还有两个类似的浮雕。这个现保存在博物馆中，另外一个与此相同，在波塞波利斯。还有一个大流士的雕像，非常珍贵，因为它上面有四种文字的题字，我们知道这些题字是奉大流士的指令在埃及制造的，内容是：我命令在埃及制造这个雕像，以向未来的人们表明，埃及被控制在波斯人的手上。  \n重要的是这个雕像背后所蕴含的思想理念，它**表明不同的民族、不同国家的人民拥有同一个政府**，当然也包括波斯人在内。波斯人不仅是统治者，他们也是其中一份子，在这样一个国际性的国家中，有许多种人他们在宗教、语言和风俗习惯等方面都是自由的。在这里我们可以看到埃及尼罗河神的标志，它也是幸福的标志，中间的颜色类似茶色，表示上下埃及在大流士的脚下统一。在铭文中，伊鞭女神对大流士说我赐给你这平原、这山川，它们在你的脚下统一为一体。  \n伊朗国家博物馆夏洛克·拉真诸  \n\n十分神奇的是，通过某种看不见的、神秘的纽带，波斯的建筑艺术在中国找到了痕迹。今天北京的**九龙壁**，**琉璃瓦装饰的墙面**，人们可以在波塞波利斯的墙壁上找到原始的主人。而波塞波利斯王宫外墙上整齐排列的雕像，在西安著名的昭陵六骏身上，也会觉得似曾相识。  \n为了宣扬自己的功绩，大流士还下令在一块悬崖上，雕刻了长篇颂文歌颂自己的丰功伟绩，这就是**贝希斯敦铭文**。铭文的内容可能有失实、夸张之处，但是这篇铭文却是解开古代两河流域文明的钥匙。  \n波斯帝国国王的野心不仅在于亚洲和非洲地区，他们又将目光瞄准了地中海西岸的希腊。希腊与波斯的战争持续了30年，最终以波斯的战败告终。波斯帝国的霸主梦破灭了，庞大帝国的统治越来越难以维持了。公元前332年，在**马期顿王亚历山大大帝的东征浪潮中，波斯帝国的统治结束了**。  \n古代两河流域文明逐渐掩盖在希腊化文明的光芒之下，但是古代两河流域文明的丰富遗产仍然影响了后来的文明。  \n\n\n\n经过漫长的几千年的发展，古代两河流域文明逐渐被淹埋在历史的记忆中。  \n当19世纪中叶以后，越来越多的考古发现让世人再次领略到，灿烂辉煌的古代两河流域文明的时候，人们才发现，原来我们生活中许多耳熟能详的故事、许多习以为常的习俗、许多司空见惯的思想行为都是从久远的、古代两河流域文明中继承下来的遗产。  \n今天，当我们回望古代两河流域人的建筑、艺术、文学、思想时，我们无法不惊叹历史的神奇。  \n古代两河流域的文化遗产非常丰富，他们创造了许多世界第一：**第一张世界地图是以巴比伦为中心的**，**最早的数学和几何学的记录、最早的天文学记录、最早的图书馆、最早的青铜冶炼技术和象牙雕刻**都出现于此。  \n建筑是凝固的艺术，古代两河流域的建筑或古朴凝重，如早期的神庙；或华丽辉煌，如亚述帝国的王宫。  \n在前面，我们已经欣赏到古代两河流域各式建筑：在**特罗、在巴比伦、在尼尼微、在波塞波利斯**。在这些地方，更让世人惊叹的发现，还有大量的古代印章，它们是古代两河流域居民的骄傲。  \n\n>滚筒式印章是石制的小圆筒，可以使用贝壳，也可以用粘土制成，你可以想象一下：有一个圆筒，其外部是雕刻画，如果在某种湿的东西，如粘土上滚动那个圆筒，粘土上就会出现一个雕刻画的印痕，当然在圆柱形表面做反向雕刻需要相当的技艺，古代的两河流域人可以做到，并达到极高的水平。  \n印章的使用与今天的中国或西方是一样的，它们可用来标识正式文件，区分上流人士，还用来标记属于某一地方或是机构的物品，作为一种辩认标志它们被广泛使用，我们发现数以千计的滚筒印章，而且在印章脱落的地方还找到许多印痕，譬如这样粘土涂在瓶嘴附近密封或涂在门锁附近封存储藏室或保护里面的东西，这是一个典型的滚筒印章，是用一种黑色石头制成的，从顶部一直到底部被打穿，这样就可以作为镯子或项链来佩带，甚至附有别针，然后佩带在衣服上，上面雕刻着这样一个情景，一个神端坐在那里，一个职位较低的女神向他引见一个人。  \n澳大利亚悉尼大学博士丹·波茨  \n\n在古代两河流域，人们为神歌唱、舞蹈、演奏。虽然今天我们已经无法听到古代两河流域的古乐，但是从这些精美的乐器上，我们还依稀可以感受到绕梁的余音；从壁画和浮雕中舞蹈者的优美舞姿中，我们还可以体会到舞蹈的节奏与韵律。  \n古代两河流域居民对环境问题非常关注，首先是对于水和洪水的认识，**世界上最早的洪水神话**就诞生在这里。由于洪水的泛滥导致两河多次改道，依靠两河的城市也随着河道的改变此消彼长。  \n据记载，一位国王为新都选址时，不惜更改河道以避免王宫受到洪水侵害。为了解决饮水和灌溉问题，他还从山上修水渠引水到山下。古代两河流域居民还认识到，土地盐碱化的危害，农民曾经给国王写信，报告土地盐碱化的面积。古代两河流域居民重视城市的规划，在乌尔，沿街道两侧修建的多为二层楼房，城市有统一的排水和进水管道，有神庙区和手工业区的差别。  \n\n>作为一种起步，文字的发明大概是最伟大的人类遗产之一。两河流域人民，苏美尔人、阿卡德人、巴比伦人、亚述人，他们都保留了丰富的记录，包括行政、文学、宗教、祈祷等等。  \n同时，两河流域人非常重视预测，因此他们成为了不起的天文学家，尽管在预测中更多的是使用占星术，然而他们对纯数学以及星体的观察达到了令人惊讶的程度。作为灌溉工作的一部分，他们使用数学来计算一块田所需用水，如此他们开始演算面积、容量，我们还知道他们从事一些非常复杂的数学计算。人们经常把两河流域文化看作西方的始祖，古典史学家则更愿把希腊看作西方的祖先，很难说清楚。作为《圣经》当然对其先前的传统有所继承，其中包括两河流域文明中口头的、书面的和宗教的传统，从这一点来说，我认为希腊人在许多方面继承了两河流域的数学，在一定程度上还有一些哲学、天文学以及《圣经》等，可以说希伯来人在《圣经》里继承了许多两河流域的宗教背景，这或许就是她传至今天的方式，通过希腊-罗马的世界，或是通过《圣经》。  \n澳大利亚悉尼大学博士丹·波茨  \n\n>古代两河流域人通过多种途径，把自己的文化传播给世界各地，他们通过贸易、通过战争、通过政府间的交往，与古代南亚次大陆地区、古代波斯湾地区、爱琴海地区、小亚细亚以及北非地区建立了广泛的联系。  \n我们可以在赫梯文明中发现赫梯人沿用了古代两河流域人的楔形文字，他们抄写了很多的神话传说，这些神话传说后来在希腊的**何马史诗和奥林匹亚山诸神**的故事中都有所体现，在南来次大陆我们可以发现来自两河流域的印章上有**南亚特有的大象的形象**，这些都是文明传播的特征和表现。与两河流域文明同时的还有古代中国的文明、古代印度文明和古代埃及文明，这些文明共同的特点都是大河文明，就是他们的文明是起源于大河的。但是与这些文明相比，古代两河流域文明又有它自己的特点：第一就是它的开放性，因为古代两河流域的地理位置决定的，古代两河流域人擅长贸易，通过贸易他们把自己的文明传播到四方，同时又吸收其它的文明。  \n中国社会科学院世界历史研究所研究员刘建  \n\n\n时光荏苒，古代两河流域文明的光彩暗淡了，当黄沙拂去，等待我们的将是灿烂的星空。","tags":["history"]},{"title":"DigestWorldHistory004古代两河流域文明（1）","url":"/2020/02/07/history004/","content":"\n在西亚境内,幼发拉底河和底格里斯河由北向南奔流直下,进入波斯湾,它们如同一对脾气性格各异的孪生兄弟,幼发拉底河平和温顺、不紧不慢、袅袅婷婷地由北向南缓缓流动，而底格里斯河则显得暴躁而任性。两河下游的**冲积平原称美索不达米亚，希腊语意思是两河之间**，西方人称这块土地为**沃月地带**，是因其形状似一弯新月，我们又称这个地区为**两河流域**地区。  \n今天的西亚由于盛产石油而富裕，而在人类文明之初，**西亚由于资源贫瘠、物质匮乏而不得不四方征战、到处迁徙**。令人称奇的是，人类文明的第一缕曙光在这块土地上升起，世界上最早的文字在这里产生，世界上最早的城市在这里建立，这一切是如何发生的？  \n\n## 农业与资源  \n\n在古时的两河流域，人们用泥土来建造房屋，用泥土来制造日用器皿，泥土是基本的生活资源，不仅如此，泥土还是古代两河流域文明的载体，他们在泥土上写字，泥土是古代两河流域文明传向四方的媒介。  \n\n>泥土在这一地区极为重要，表面看来这一地区资源贫乏，但这里有幼发拉底河，所以有很多水，还有很多芦苇和大量的泥土，这儿没有建筑用的石头，也没有金属一类的矿藏可供开采，但是这里有大量的水和泥土，可以说这是用泥土建造起来的文明。  \n澳大利亚悉尼大学博士丹·波茨  \n\n这一文明最早的创造者是**苏美尔人**，他们创造了一种全新的农业生产方式——**灌溉农业**。  \n\n>灌溉创造了这个文明，早期大规模的灌溉系统始建于公元前6000年，但真正发展起来是在公元前3000年以后，正是大规模的灌溉造就了我们所说的两河流域文明，**苏美尔人、阿卡德人、巴比伦人**等先后生活在现今伊拉克的南部地区。  \n澳大利亚悉尼大学博士丹·波茨  \n\n### 发现苏美尔文明  \n\n在幼发拉底河和底格里斯河的交汇点上，有一个叫**特罗**的小地方，从1877年到1900年，在这块12平方公里的土地上，一个叫德·萨西的法国人率领考古队展开了大规模的考古活动。呈现在世人面前的考古发现让人瞠目结舌，三万多块刻有文字的泥板，刻有两千多行铭文的圆筒形印章及各式雕像，他的发现开始让世人了解**世界历史上最早的人类文明——苏美尔文明**。  \n\n大约在6500年前，苏美尔人来到两河流域的最南端定居，他们在冲积平原上建立起房屋，在冲积平原上耕种粮食、栽种果树、在沼泽中捕鱼。  \n大约在4900年前，苏美尔人建立了**世界上最早的城邦国家**，在苏美尔地区先后产生了十几个城邦。  \n\n>两河流域地区以城市著称，其规模比纯粹的市中心要大，我们称之为城邦，因为它包括城市，周边的耕地以及有人口众多的村庄。  \n澳大利亚悉尼大学博士丹·波茨  \n\n在每个城邦中都有一个统治者，城邦统治者像一个大家族的族长，要主持城邦内的一切事务、发动和指挥城邦间的战争、主持宗教的仪式、建造和修缮神庙、组织贸易活动等等。  \n这是**拉格什城邦**的统治者**乌尔南塞**。画面中，乌尔南塞头顶砖头，正在为拉格什城邦的守护神**宁吉尔苏**修建神庙，旁边是他的妻子儿女。  \n\n#### 阿卡德人\n\n大约4300年前在苏美尔地区北部，**阿卡德人**的势力越来越强大，逐渐吞并苏美尔人的城邦国家。他们的杰出领袖**萨尔贡**，率领他的精锐部队长驱直入，统一了苏美尔地区，建立了**古代两河流域第一个统一国家**，并在苏美尔地区的北部建立国家的新首都，定名为**阿卡德**。  \n\n>萨尔贡作为一个领袖，他创建了许多第一，他创造了世界上第一个地域性的王国，他创造了最早的中央集权制统治的雏形，他建造了世界上最早的首都，当然除了这些之外，他最传奇的地方就是他的出身，这是他为自己编造的：他一出生就被母亲抛弃，然后由一个园工抚养长大，从下人做起，成为一个宫廷官员，最后成为一代霸主。  \n中国社会科学院世界历史研究所研究员刘建  \n\n>萨尔贡是第一个征服，统一了两河流域各城邦的人，征服两河流域南部地区后，他开始转向北方，一直打到今天的土耳其，伊朗西部，他被视为世界上第一个帝国的建造者。  \n澳大利亚悉尼大学博士丹·波茨  \n\n到萨尔贡的孙子**纳拉姆辛**统治时期，王朝的统治达到鼎盛。  \n图中身材最大的就是纳拉姆辛，根据这个时期**两河流域人的绘画传统，身材最大的人就是最重要的人**，他头上弯钩形状的装饰就代表着神，这是他违背传统自封为神的证明。为此后世两河流域人将阿卡德王朝的灭亡归咎于**纳拉姆辛对神的蔑视**。  \n>这是它的传说，但它真正的原因，据说有两种：一种是认为外族入侵，导致阿卡德王朝的灭亡；另外一种认为高度的中央集权和财富的集中，导致王朝的最终灭亡。当然还有一种观点就是认为，气候原因导致了整个王朝的灭亡。  \n中国社会科学院世界历史研究所研究员刘建 \n\n#### 乌尔第三王朝\n\n阿卡德王朝灭亡100多年后，两河流域迎来了新的统一王朝——乌尔第三王朝。乌尔第三王朝时期又称为**新苏美尔时期**，这个新的苏美尔王朝的创建者，**乌尔那木**原来是乌尔城的一个军官，他重新统一了两河流域南部，阿卡德和苏美尔地区。他的儿子**舒尔吉**巩固父亲建立的王朝，并且将王朝建设成为两河流域有史以来最强大的国家。他颁布了世界上第一部法典，因为许多学者误认为这部法典是其父乌尔那木颁布的，因此一般被称为**乌尔那木法典**，这部法典是后来那部名扬天下的《汉穆拉比法典》的蓝本。  \n乌尔第三王朝是苏美尔文明发展的鼎盛时期，100多年后，当乌尔第三王朝灭亡时，苏美尔文明并没有随之消亡。  \n\n>即使在苏美尔人国家灭亡之后，苏美尔文明也被其它民族建立的国家继承，可以说苏美尔文明是古代两河流域文明的核心和基础。  \n中国社会科学院世界历史研究所研究员刘建\n\n苏美尔人崇尚武力、崇拜英雄。《吉尔加美什史诗》是两河流域流传最广的故事，他讲述的是一个英勇、多情、充满悲剧色彩的英雄故事。  \n\n>《吉尔加美什史诗》是我们从泥板中发现的，这些泥板比吉尔加美什本人所处时代要晚许多，吉尔加美什是个真实的历史人物，他在苏美尔王表中被称作**乌鲁克王**，乌鲁克是公元前2900年左右最大的苏美尔城邦之一，据说吉尔加美什建造了乌鲁克的城墙，吉尔加美什是一个神秘的、史诗性人物，他不是（希腊神话中）大力神式的人物，他没有那样的体质和天赋，但他是一个伟大的、有追求的人，他追求不朽，这很重要。这类故事一般经口头传播，但我们拥有文字版本，而且我们知道公元前7世纪的亚述国王阿述尔巴尼拔在他的尼尼微图书馆里保存有多种不同的版本。  \n澳大利亚悉尼大学博士丹·波茨  \n\n除了崇拜英雄，苏美尔人还虔诚敬神，他们向神祈求风调雨顺、五谷丰登、国泰民安。  \n在苏美尔各个城邦中，最高大辉煌的建筑就是神庙。  \n每个城邦都有一个保护神，各个保护神的神庙就是城邦和城邦之间，甚至是苏美尔地区与周边地区之间经济活动的中心。这个时期神庙最高处的**多层塔式建筑**，是古代两河流域文明建筑的特色。  \n苏美尔人勤奋、好学，学习是他们永远的职业。苏美尔人创造了世界上最早的学校，在**尼普尔**发现的校舍有两间，大的可容纳45人，小的可容纳23人，在教室中还保存着学生做作业用的泥板，学校教育的目的是为王室和神庙培养书吏，教授苏美尔语语法、写作、书法以及代数、几何、自然等课程。  \n在古代两河流域历史中，**书吏的工作非常广泛**，在政府机关中、在军队中、在王宫中、甚至在私人庄园中都有书吏的身影。  \n\n由于地理环境十分贫瘠，而且两河流域所处的地理位置四通八达，**苏美尔人擅于经商和对外交往**。  \n早在6000年前，在阿富汗、在印度次大陆、在小亚细亚、在波斯湾沿岸就已经可以看到苏美尔商人的身影。在陆地或是海上，他们将两河流域的粮食、鱼肉制品等运往各地，带回木材、石料、矿产等生活必需品，当然还有一些奢侈品。  \n伴随着苏美尔商人的活动，苏美尔文明传向四方，而其传播载体就是用**苏美尔语书写的楔形文字泥板**。  \n>在楔形文字中，苏美尔语是一种最重要的语言，但是苏美尔文是一种死文字，今天已经没有任何国家和民族还使用它，所以已经不能称其为纯粹的语言。  \n中国社会科学院世界历史研究所研究员刘建\n\n>大约公元前3400年，是用一种叫做前楔形文字的在该地区开始出现泥板和最早的文字，准图画文字写成的，经过几百年的发展，它最终成为楔形文字，苏美尔语是第一种使用这种文字的语言。但在公元前2000年以后，苏美尔语只用于书写，绝大部分人可能说**阿卡德语**，然而苏美尔语文献仍然存在，并且几乎一直延续到公元前后，那时的苏美尔语有些像是我们对拉丁语或古希腊语的认识，那时还有人认识讲阿卡德语的学者仍然在研究，但这时苏美尔语已经仅仅是一种书面语，一种用于宗教赞美诗及其他文章的语言。  \n澳大利亚悉尼大学博士丹·波茨  \n\n从地域上说，苏美尔与中国相去甚远，但同是东方人，同样是世界上最古老文明的创造者，两个文明在许多方面都有相似之处。苏美尔人与中国人之间似乎有一种天生的亲切感，我们中国人似乎有更多的便利去探索、去解决苏美尔文明中的未解之谜，苏美尔人那深邃的眼睛正充满期望地等待着。  \n\n## 巴比伦文明\n\n1901年在现今**伊朗的苏萨遗址**，发现了一块高大的黑色玄武岩石碑，石碑上部雕刻的画面描绘的是一个叫汉穆拉比的国王，从正义之神、太阳神沙马什手中虔诚、郑重地接过象征权力的权杖。汉穆拉比就是**巴比伦文明**最重要的缔造者，他于公元前1792年登上王位。让汉穆拉比万古流芳的不是他的赫赫战功、四方征过的功绩，而是他颁布的一部法典，即《汉穆拉比法典》，这是迄今为止世界历史上第一部完备的成文法典。  \n《汉穆拉比法典》全文刻在黑色玄武岩的下半部分，全文分三个部分：前言、正文和后记。前言是汉穆拉比王向世人宣告自己的权利是神给予的，自己是世界上最伟大的王。最值得注意的是，他宣称他颁布法典的目的是发扬正义于世，灭除不支邪恶之人，使强不凌弱。法典正文共有282条法律条文，包括对刑事犯罪，如杀人罪、盗窃罪、强奸罪等的处罚规定，以及对民事纠纷，如借贷、转让、婚姻等方面的处理原则，甚至还规定了房、土地出租的租金，婚姻的礼金和聘金的额度等等。后记再次宣扬汉穆拉比王的公正，希望法典传之后世，并诅咒敢于破坏法典石碑的人。  \n古代两河流域居民是非常重视法律的民族，在两河流域地区考古发现的文献中，**各种各样的契约和合同占据绝大多数**，土地买卖、房屋租赁、婚姻合同，甚至耕牛租借，当事人双方都要签订契约或合同，并且有证人当场作证签名。  \n\n### 古巴比伦王朝  \n\n汉穆拉比开创的巴比伦王朝，在历史上被称为巴比伦第一王朝或古巴比伦王朝。巴比伦得名自王朝的首都巴比伦城。\n在统治近400年后，来自小亚细亚赫梯王国的国王率领大军攻陷了巴比伦城。  \n\n### 赫梯王国  \n\n赫梯王国创建于大约公元前17世纪，其首都**哈图沙**位于今土耳其首都安卡拉南。赫梯人是来自黑海北部的印欧语族的民族，在公元前14世纪时，赫梯国家的统治达到鼎盛，赫梯人长期垄断冶铁技术，这使他们在很长一段时间内保持着强大的军事优势。赫梯人使用古代西亚通行的楔形文字为书写文字，却延用印欧语族的语法特点。赫梯国家地处欧洲和亚洲之间，这些都是赫梯文明成为古代文明研究中的一个十分特殊的领域。  \n\n### 中巴比伦王朝\n\n接替古巴比伦王朝的中巴比伦王朝，是由来自北方山区的**加喜特**人创立的，因此又称**加喜特王朝**，它是古代两河流域历史上统治时间最长的一个王朝。加喜特王朝统治长期处于积弱状态，这给予两河流域北部地区的**亚述人**提供了充分的发展空间和壮大机会，亚述人很快从一个固守北部一隅的地方诸候小国发展成为帝国。  \n\n### 新巴比伦王朝\n\n当新巴比伦王朝重新控制两河流域南部地区时，已经是在六、七百年之后了。新巴比伦王国的辉煌超过了汉穆拉比王统治时期，**新巴比伦王国的创建者是迦勒底人**，他们是科学史上值得大书特书一笔的民族，他们编辑整理的《**巴比伦日志**》记载了每月的天文现象、货物价格、水位和天气状况，是世界上最早的天文记录之一。新马比伦人的天文学知识十分先进。  \n\n>天空被分为12个相等的区域，正如我们今天所知道的黄道十二宫图，他们用符号标志，我们已经知道大约有九个符号来代表这十二个区域，即当时的黄道十二宫，这是天文学的划分，它也是一种行政管理体系，是一种非常先进的体系。  \n伊朗国家博物馆夏洛克·拉真诸  \n\n新巴比伦王国最著名的王是**尼布贾尼撒二世**，他于公元前605年9月7日继承王位，**他是《圣经》中记载的巴比伦之囚时的那位国王**。尼布贾尼撒在四处征战之余，将国家的财政储备几乎全部用于巴比伦城的建设之中，著名的**空中花园**据说就是尼布贾尼撒为来自米底的王妃建造的。巴比伦城的建筑美伦美奂，巴比伦人的生活奢侈豪华，苏美尔人开创的两河流域文明经过巴比伦人的继承发扬向更加广阔的地区传播着。  \n当亚述人取代巴比伦人，成为两河流域新的主人时，他们也同时接过了传播两河流域文明的接力棒。  \n孕育了苏美尔文明和巴比伦文明的幼发拉底河和底格里斯河仍在不懈地奔流向前，她们将继续见证两河流域文明更加灿烂辉煌的未来。  ","tags":["history"]},{"title":"DigestWorldHistory003古代文字的起源","url":"/2020/02/06/history003/","content":"\n文字是人类文明的一个重要的象征，文字的发明比人类历史上的任何其他发明都重要许多，它也改变了世界，语言和文字让人类可以更有效地交流。我们的先民是如何学会写字的呢？这些早期的文字都记录了怎样的思想和信息呢？在人类文明的摇篮时期，人们使用的语言和文字已经像谜一样。那么，研究人员又是如何在它们长达几千年的沉寂后，又把它们破解了呢？从人们鸿蒙初醒的时期，人们就试图用图像和符号描绘自己所处的环境，如古代西亚、埃及、中国和印度，有文字记录的历史，可以追溯到四千到五千年以前。语言和文字将人类与动物、文明与野蛮区别开来，人类最早的文字书写遗迹是在位于古代西亚的尘封的大地中保存的，那么现在就和我们一起来看一看这一人类历史上最为伟大的发现。\n\n## 楔形文字  \n\n正是商业和贸易的发展促进了早期的文字的发展。交易数目只要超过一个人可以轻易记住的数字两河流域居民便使用土块把它们记录下来。早期人类的书写是在潮湿的泥板上刻画动物的形态，然后将泥板在阳光下晒干，这就是最早的象形文字。随着时间的前进，人们发明了许多标准的图画和抽象的含义，比如用一个碗表示食物，一个人头加一个碗表示吃，这个图片形成了一种符号。人们发现在泥板上刻出几个程式化的标记，来象征一种物体的方法比描绘出真实的物体要容易快捷得多。  \n大约公元前2500年，人们开始使用芦苇杆在泥板上刻画符号。芦苇杆的尖端在泥板上留下的痕迹比杆身要粗，形状就像楔子，这种文字就是我们现在所说的楔形文字。楔形文字包括三种基本符号：水平楔形、垂直楔形和斜形楔形。楔形文字一词来自于拉丁文字库里也斯楔子的意思。接下来的两千年中，楔形文字成为古代西亚人民的通用文字。  \n到公元前十四世纪，用阿卡德语书写的楔形文字，已经成为西亚北非地区的通用文字。连埃及人、赫梯人、叙利亚人和古波斯人也都使用楔形文字。虽然楔形文字的使用在古代非常盛行，但是它没能流传到今天。那么，我们今天又是如何知道早期先民通过这些文字所表达的思想观念和情感的呢？  \n在1685年意大利探险家瓦来，游历两河流域地区，发现一些有着奇怪符号的砖块，由此人民对古代语言开始感兴趣。在给朋友的信中，他抄写了五个楔形文字符号，并解释了文字的书写方向，他是最早尝试解读楔形文字的人。  \n1761年和1767年丹麦数学家、作家卡尔期腾·尼布两次游历西亚地区，并记录了西亚地区独特的地域风光和古代遗址。因为他穿着当地人的衣服，所以在从丹麦出发的这个六人小组中，他是唯一幸存下来的。他的作品深深吸引着欧洲人的目光，引起了他们的兴趣。随着近探险者和欧洲各国特别是英法在西亚地区不断有重大的考古发现,人们开始尝试破译那些写在泥板上、刻在石碑和神庙宫廷墙壁上的文字  \n>当一个文明死亡了的时候，它往往还留下了一些线索，而文字的破译就是重新开启这些古代文明的钥匙。在**埃及**十九世纪，一个法国士兵发现了**罗塞塔石碑**，上面的三种文字成为后来法国人商博良破译古代埃及及象形文字的基础。在古代两河流域，**波斯的贝希敦铭文**上的三种文字也成为破译古代两河流域楔形文字的钥匙。  \n中国社会科学院世界历史研究所研究员刘健  \n\n**格罗特芬**是一名教师，出生于1775年，他的破译工作是从他和同事的一次打赌开始的。当时欧洲许多一流学者纷纷尝试破译，在**波塞波利斯**发现的几片铭文，但均无功而返，他们宣布这是无法解决的问题。格罗特芬将这看作是对他智慧的挑战，格罗特芬所学专业的哲学，而不是语言学，他的破译努力大多来源于逻辑推理和猜测，他首先推定他手中的几篇铭文是有关波斯商国国王的文献，**他猜对了**，这种逻辑推理帮助他破译了铭文。  \n1835年，英国军官**罗林森**被任命为波斯**克尔曼沙克省**省长的军事顾问。还在上任途中他就听说了波塞波利斯郊外刻在悬崖上的**贝希斯敦铭文**的故事。罗林森的破译工作是从亲自临摹铭文开始的。贝希斯敦铭文完全用楔形文字书写，后来经研究发现，这段楔形文字铭文包含着三种古代文字。经过十年的努力，到1847年，完整的贝希斯敦铭文已经被复制下来，终于在1852年他完成并发表了他的解读成果，他解读了这段铭文，其内容是关于大流士-一位古代帝国的统治者及其统治的人民的。到十九世纪五十年代中期，巴比伦楔形文字的破译更为准确了。  \n\n>楔形文字有三种书写体系：表意、音节和字母书写体系。  \n由于书写体系的不同，就决定了用字数量的不同，表意体系用字最多，到目前为止，我们发现了1200多个符号，但是实际用字数量可能要远远超过这个数字；音节体系只用这600多个符号；而古波斯的字母体系仅仅用了36个符号。虽然楔形文字被用来表达多种不同的语言但是它们都没有超过这三种体系。  \n北京大学外国语学院教授拱玉书  \n\n## 象形文字  \n\n当所有这些文字破译成功后，人们能够从楔形文字发展的脉络中审视文字的历史了。在楔形文字破译之前，法国人已经破译了发源于埃及的、另一种古老的文字-象形文字，寻找文字起源的历史可以说从埃及开始。  \n1798年春，法兰西科学院的一次科学家大会上，拿破仑拿着一本尼布尔写的《阿拉伯及附近各地游记》发表了演说，布置了科学家在埃及研究方面的任务。几天后，他便率领远征埃及的部队出发了。拿破仑对埃及的远征当然是个错误，但是他却在欧洲甚至全世界的范围内，掀起了研究古代文明的热潮。  \n1799年8月，法国远征军的一个士兵在尼罗河下游三角洲西部、一个叫做罗塞塔的地方，发现了一块黑色太阳石石碑，上面刻有三种文字符号，这就是著名的罗塞塔石碑，它成为了破译这些古老语言的钥匙。上面的三种文字符号中，最下面的一种是希腊文字母，其余两种是还不为人所知的象形文字符号和埃及语世俗体文字符号。罗塞塔石碑一被发现，石碑上的文字就被拓印下来，分发给所有感兴趣的学者，其中一份拓印本落入一个瑞典外交官、阿克布拉德手中，他精通多种东方语言。在对石碑上的三种文字进行比较后，他发现三种文字实际上是同一篇文献。这是托勒密王五世在公元前196年3月27日颁布的对**神庙捐赠诏书**。但是，最终成功破译埃及象形文字的是年青的法国学者、语言天才**商博良**。他从很小的时候，就知道了罗塞塔石碑的故事，他将一生都投入了对埃及象形文字的破译之中，从此，埃及文明的神秘面纱被慢慢揭开。  \n古代埃及人相信，他们的文字是神创造的，是**文字之神和智慧之神托特**向古代埃及人传授了文字书写的方法。古代埃及人还相信，他们的语言也是神的语言，是神给人类的礼物。  \n英文的**象形文字hieroglyph**一词是由古希腊的神灵和雕刻两个词组成的。据说就是因为古希腊人在埃及看到刻在神庙墙壁上的象形文字而创造的。  \n实际上，埃及象形文字是由绘画文字演变过来的、一种最古老的文字形式。象形文字最早出现在大约5500年前，稍晚于古代两河流域楔形文字的产生时间。  \n公元前3500年到3100年图画文字中开始出现表意符号和表音符号。  \n最典型的早期象形文字铭文，就是公元前3100年**帕勒摩石碑**，出土于上埃及。最经常使用的符号大约共700个，到罗马时代增长到5000个。  \n根据加德纳对象形文字的分类，表现男人及各种职业的不同符号共55个、表现女人的符号7个、表现鸟的符号54种、表现建筑物和建筑物一部分的符号有51种。象形文字通常刻在石碑上，或者寺庙和陵墓的建筑物的墙壁上，有时也出现在纸草上。但是后来其使用范围越来越局限在纪念碑上。  \n\n>这里的一部分，也就是最上面的部分是他一生中想要什么？喜欢什么？各种不同的食物、各种面包、蛋糕、葡萄酒、啤酒和肉类，一切都写在这里；第二部分也就是更大的部分是这个人的身份陈述，他的姓名和头衔，这个人尤其自豪的提到他是国王的发型师。你要描述一个人不仅要用他的姓名，而且要用他的头衔，所以如果一个人有头衔就会先写出头衔，姓名然后是形象。石碑上的铭文包括三部分的内容，如我刚才所说他喜好，他的身份特征和他的形象。  \n埃及史学家卡纳瓦蒂  \n\n### 象形文字演变\n\n象形文字是人类历史上最古老的文字之一。但是由于象形文字的局限性，它无法满足日前复杂的人类社会的交往需要，并逐渐被其他文字取代。  \n在第十四王朝或稍早，埃及人发明了更为快捷的**僧侣体**书写形式。  \n大约在公元前700年左右，**世俗体**文字取代僧侣体。世俗体文字在托勒密和罗马统治时期是通用的文字形式。  \n三世纪时，**科普特**文字诞生。基督教传入埃及后，<u>埃及人为了抄写和翻译《圣经》的方便，借鉴希腊文的24个字母，加进7个世俗体文字作为补充字母，创造了科普特语。</u>  \n在阿拉伯人征服埃及后，科普特语逐渐被**阿拉伯语**代替。  \n现存最晚的象形文字文献是**394年的费来铭文**。  \n\n## 字母文字  \n\n今天在世界大部分地区使用的字母文字，也是首先在西亚地区产生的。公元前2000年前后，在**巴勒斯坦的拜不勒斯**出现了一些文字，因为有些文字像象形文字，因此被称为伪象形文字。伪象形文字有80个符号，较之几百个埃及象形文字符号和几百个楔形文字符号，伪象形文字的字符数已经少多了，这种伪象形文字开始向更少的文字符号努力。  \n公元前1500年左右，在**西奈半岛**出现了**原始西奈字母文字**文献。  \n公元前1000年，**腓尼基字母文字**基本形成。腓尼基字母文字被认为是**西方希腊和罗马字母文字的源头**。  \n公元前7世纪，这种字母传给罗马人，成为拉丁字母的基础。拉丁字母随着**罗马帝国的扩张**和**基督教的传播**，成为欧洲各国的文字。随着**地理大发现**，又传到美洲、大洋洲等地。  \n这些古代文字的重要性和影响，即使今天也十分显著。 \n\n## 中国文字  \n\n中国人今天使用的文字，仍然是象形文字。它是目前世界上使用人数最多的一种文字。也是人类历史上诞生最早的文字中唯一没有消亡的文字。和西亚的楔形文字、埃及的象形文字一样，最初中国人用一些图画表达思想。  \n在**6000年前的西安半坡遗址**中，存在着人类文明的遗迹。在那里发现了刻有图案和符号的陶器，后来这些图画具有了抽象的含义，汉字产生了。\n\n>文字起源的传说，在说文解字中说神龙氏结绳为治而统其事，庶业其繁，饰伪萌生。它的意思就是说：神龙氏最初用结绳的方式记载日常事物，但时间一长麻烦事儿越来越多，产生了很多误解后来皇帝的史官仓颉就根据动物行走的痕迹创造了文字，当然这只是一个传说，中国文字的形成有一个非常漫长的过程。\n中国社会科学院世界历史研究所研究员刘建  \n\n公元前221年，秦始皇统一中国后对汉字进行了规范，小篆成为官方文字，而在民间隶书逐渐成为通行文字。  \n汉字的造字方法被古人总结为：象形、指事、会意、形声、转注和假借。汉字音、形、义分离组合的造字原则对不同发音的语言适应性很强。不同民族和地域的人尽管口音不同却能使用同样的文字，这对于封建王朝的长期稳定和中国文化的传承具有决定性的意义。  \n随着中国文化的扩散，周边许多国家和民族的文字都受到汉字的影响。  \n中国古代的西夏，契丹和女真文字，日本、朝鲜和越南文字都能见到汉字的影子。  \n\n## 书写材料\n\n书写材料对于人类文明的启蒙作用是不可估量的。**拥有廉价的书写原料的地方，人类文明程度相对就要普及。**早期文字的书写材料走过的历史，是从庞大笨重、走向轻巧易携带、廉价。  \n在古代**西亚**地区，**泥土**是最廉价的书写材料，制笔用的**芦苇**在三角洲地地区更是随处可见，因此泥板在十分长的时期内是最重要的书写材料。而到了**小亚细亚**，情况就不同了，在小亚细亚的赫梯王国的遗址中，发现的泥板文献全部是王室文献。有人相信**赫梯**人从两河流域引进了新型文字的书写方式，因此也引进了书写楔形文字用的泥板和芦苇笔。由于这两样材料在小亚细亚并不多见，要依靠进口，因此廉价的泥板和芦苇笔就成了可居的奇货，变得贵重起来，成为王室的专利。  \n在**埃及**，书写材料要丰富的多。**纸莎草**是尼罗河三角洲地区遍地可见的植物。纸莎草处理和压制成页都非常简单，莎草纸记录和携带储存也都很方便。纸莎草的使用帮助古代埃及人建立了一个延续了数个世纪的文明，其影响直到今天依然十分显著。通过交流，纸莎草从埃及传到古代希腊和罗马。今天英文纸一词，就来源于纸莎草希腊文单词。   \n在古代中国，文字的书写材料，从陶器到甲骨、简牍、丝帛、金石等，而中国影响世界的重大发明中，就有对书写材料的重大变革，发明造纸术。  \n书写的材料多种多样，书写方向和字体也五花八门。有的从左到右书写，有的从右到左，有的从上到下，有的没有固定方向。对于早期学者来讲确定书写方向，在破译文字中，是个很具有挑战性的难题，但是象形文字可以给我们一点线索。通常方向，可以从文中表示人或动物的象形文字符号的朝向决定。  \n今天，各种文字大都采用从左到右、横向书写的方式。只有在我们的书法作品中，才可以看到各式各样的书写习惯。\n\n## 今日语言  \n\n今天，世界上存在超过2000种语言。使用人数在百万以上的有200多种，千万以上的有50多种，较大语种的使用人数超过全球人口的96%，其余不到4%的人口讲着2000多种语言，正处于不断消亡之中。  \n\n>一种语言就是一个人，语言就是人类。每个时期都会留下各种思想、观念和文学的财富，忽略任何一个时期都是很遗憾的。因为每个时期都有每个时期的天才以及他们留下的思想，所以我们确实有必要让所有语言活着，特别是古代语言。  \n埃及史学家卡纳瓦蒂  \n\n>文字对我们今天世界的最大贡献就是一个保存，我们说以史为鉴，通过这些文字资料，我们可以知道古代人怎么样思考？怎么样的与人交流，他们信仰什么？他们有什么样的爱好？他们的日常生活是什么样的？也是由于这些文字资料，我们可以知道历史的兴衰更替，对于我们今天以及未来的发展都是有非常大的作用的。  \n中国社会科学院世界历史研究所研究员刘建\n\n没有人能确切的说出，世界上曾存在过多少种语言。但是像这些在哈拉帕文化遗址发现的古印度河文字一样，仍然有许多已经被历史尘埃淹没的文字，正等待着人们去挖掘破译。","tags":["history"]},{"title":"DigestWorldHistory002文明的起源","url":"/2020/02/06/history002/","content":"\n>在历史学中同文明相对应的文化，通常用来指尚未发明文字、总体发展水平比较低的社会或时期，但它的广义是指：知识和艺术成就，如文学、艺术、哲学、科学等等。文明一般是指一种先进的文化，很多学者用文明一词指与原始相区别的、较高的人类历史发展阶段，也就是阶级社会或者说是文明社会。文明是文化发展到较高阶段的产物，当某个阶段的文化，比较广泛的使用了文字，人文科学和自然科学已经初步形成，社会成员被划分成了阶级或等级，社会制度、政治制度、经济制度已经比较完备，出现了巨大的公用建筑甚至城市中心，那么发展到这种程度的文化，就可以称作文明。  \n山东聊城大学历史文化学院教授 陈德正\n\n如此看来，文明不是从来就有的，它的起源涉及世界各地区，由旧石器到新石器，再到金属器的生产力的发展，各部落由狩猎采集进而畜牧农耕，产生社会大分工，导致社会分裂为阶级的具体过程。还有从游牧到定居及城市的出现，由血缘关系到阶级关系的发展，最后通过不同的途径形成国家等诸方面。\n\n现代世界三大基本技术的雏形:\n+ **石器打制技术**，它是**机器制造技术**的雏形\n+ **人工取火技术**是**能源转化技术**的雏形\n+ **有声语言**是**信息技术**的雏形\n\n## 气候变化\n\n约1万5千年前，旧石器时代开始向新石器时代过渡，此时，全球的气候和生态环境发生了显著的变化。随着第四纪最后一次冰期的结束，全球气候转暖。欧亚两洲的冰原被森林和草原所取代，而非洲的气候也由多雨转为干旱，南欧与西亚一带开始出现类似今日的温和景象。旧石器时代的不少大型动物灭绝，数量大为减少，适于森林草原地区的小动物和鸟类增多，人类的狩猎对象随之发生变化，经济活动的内容扩大，江河湖海地区出现了渔猎经济。\n\n经济活动的变化促使生产工具发生变革，石器制作上更为精细，首先把石器打制成一定的形状，然后把它放在砺石上蘸水加砂磨光，用这种方法制成的石器表面平整光滑、器型规整、刃部锋利、可多次使用，集不同质材之优点于一身的复合工具也于此时流行开来，尤其是新型远距离攻击武器——弓箭。它的发明和使用直接促进了早期人类狩猎业的发展，但狩猎业的发展却不能永久满足人口增长和人类发展所形成的新需要，于是，一场人类的生活方式大变革不可避免地发生了。这是新石器时代发生的最具影响力的事物，这就是农业革命。\n\n \n## 农业革命\n\n### 发源地\n\n农业革命首先发轫于西亚，约在9千年前，伊拉克北部的耶莫地区即已种植大麦、小麦 小扁豆等农作物。约旦河谷的耶利哥、土耳其的沙塔尔、休于也有农业生产的考古遗存。此地之所以成为农业革命的发祥地，除了这一地区的地质、气候和动植物分布的特点外，还与它作为亚非欧三洲的联结点的地理位置有关。从冰期消逝以后，它开始发挥古代世界各族文化信息交流枢纽的作用，从此一直在古代世界的历史舞台上扮演着重要角色。除西亚外，东亚和中南美洲也是世界上最早的农耕中心。在中国河南新郑的裴李岗遗址，已有粟和众多石制农具的发现；同时期的河北磁山遗址，则发现有厚达2米的粟类粮食堆积层；而浙江河姆渡遗址，则发现了世界上最早的稻谷遗存，堆积层也厚达1米。\n\n\n### 动植物驯化种类\n\n在中美洲墨西哥，公元前5千年左右培育了玉米、南瓜和胡椒等作物；在秘鲁，公元前6千年就种植菜豆，公元前5千年到4千年间又开始种植玉米、马铃薯、南瓜和辣椒。\n\n农业革命最主要的标志是植物的人工栽培和动物的人工驯养，以人工栽培植物为特点的原始农业由采集经济发展而来。人们在长期采集中，通过仔细观察，逐渐熟悉了植物的性能和生长规律，并掌握了栽培方法。从近代一些民族的采集活动，可以看到从采集经济过渡到原始农业的一般情况。\n\n19世纪，马来半岛的居民在采集过程中熟悉了野生果树的生长规律，为了取得好收成他们修剪树枝、砍去树旁的杂草和灌木；澳大利亚土著居民给野生谷物除草，挖出著芋类植物的块茎，再埋到地里；安第斯山区的印第安人，从60多种野生马铃薯中，选择出优良品种进行培植。\n\n动物的驯养大约是和农业一起发生的，许多人认为动物的驯养源于狩猎。有一种说法认为猎人打死母兽后，幼兽得到人们的饲养，后来成了家畜。还有一种说法认为，猎人把一些野兽驱赶到预先设置的栅栏内，以便捕杀食用，其中一部分被圈养成为家畜。\n\n与早期农耕中心出现的同时，畜牧业也在人类长期狩猎经验的基础上起源了。北美印第安人率先驯化了狗，同时，西亚人独自驯化出狗、山羊、绵羊，稍后猪、牛、马、鸡、鹅、骆驼等动物，也陆续在亚洲和欧洲驯化成功。\n\n农业革命对于以后人类的发展，产生了深远的影响，人类的物质生产出现了 第一次历史性的飞跃，人类一改数百万年，依附于自然界恩赐的地位，对谷、麦、稻和玉米等农作物进行培植，从以狩猎采集为主的生活转变为以农耕畜牧为主的生活，从食物采集者过渡到食物生产者。\n\n \n\n>农业革命同后来的工业革命一样，都是人类历史上划时代的伟大变革。这场革命使人类从以采集狩猎为主的生活过渡到了以农耕畜牧为主的生活，从食物的采集者变成了食物的生产者，这场食物获得方式的变革也改变了人与自然的关系，人类开始了从被动地依附和适应自然到主动地改造利用自然的历史性转折；  \n这场转折还极大地提高了劳动效率。据测算，原来650平方公里的土地只能维持25个采集狩猎者的生活，而这时15平方公里的土地就可以养活150人的农民群体。  \n另外，农业革命还改变了人类的生活方式，人类从原来漂泊不定的迁徙生活过渡到了村落定居生活。  \n山东聊城大学历史文化学院教授 陈德正\n\n### 生活方式\n\n农业革命最明显的影响是产生了定居这种新的生活方式，农业生产从播种到收获要经历一段相当长的时间，这样，必然要求农作者定居，于是，新石器时代的农业村落取代了旧石器时代的流浪团体而成为最基本的经济文化单位。实际上，它构成了18世纪末期之前一直居统治地位的一种生活形式的基础。\n\n早期农业村落的代表性遗址有**伊拉克的耶莫**。耶莫遗址宽约90米、长约140米、沉积达7米、分为16层，最下层用放射性碳素定年为公元前7000年到公元前6750年。这里约有25座住宅，均为泥墙房屋，屋顶用茅草覆盖，地板以芦苇涂泥铺就，估计居民有150人。\n\n**沙塔尔休于遗址**的面积达13公顷、人口有五六千人，它存在的年代，约在公元前6500年到公元前5400年之间，按规模看，它已是当时西亚地区最大的居民点，甚至可称为世界上最早的城镇。虽然这个遗址比耶莫规模更大，但也只能说是早期的人类聚居地和定居点，最多属于市镇的雏形。**真正的城市的出现，城市革命是伴随着金属器的使用发生的**。\n\n \n### 工具变迁\n\n金属器取代新石器也有一个过程，考古学家将这一过程分解为金石并用时代、青铜器时代和铁器时代三个阶段。\n\n#### 青铜器时代\n\n早在新石器时代末期， 人们已知使用天然金属。在土耳其的恰约尼遗址，发现了用铜矿石直接打制的钻孔珠、扩孔锥、别针等，年代为公元前7600年左右。约在公元前4000年，西亚和印度一些地区开始冶炼纯铜，俗称红铜。人们在冶炼纯铜的实践中，逐渐学会冶炼铜和锡的合金青铜 。公元前4000年代末，两河流域和多瑙河流域出现青铜器。至公元前3000年代，两河流域、印度河流域已普遍使用青铜器。\n\n#### 铁器时代\n\n公元前2000年代后期，冶铁术也被发明了出来。世界上最早发明炼铁技术的是赫梯王国，时间为公元前1400年前后。他们曾垄断冶铁术并禁止任何铁器出口达200年之久。\n\n伴随着农业的产生和生产工具的进步，人类的生活组织方式也悄然发生着变化。人们开始在适合于农业生产的地方定居下来，人类早期聚落出现，最早的聚落面积不大，依靠水源和耕地而建。\n\n\n### 社会结构\n\n#### 聚落变化\n\n随着农业技术的发展，人们对于土地支配的能力加强了，相应地不再需要更大面积的土地就可以维持生存需要了，而且交换的需要增强了，聚落间联系加强了。很快，聚落间为争夺水源和生活必需品产生矛盾和冲突，聚落间的冲突演化为战争并最终导致聚落兼并现象出现。在古代两河流域地区，在公元前4000年左右，出现聚落数量急剧减少，而聚落规模急剧扩大的现象，这就是聚落合并的结果。\n\n#### 阶层等级的出现\n\n农业生产的稳定发展，导致了人口的增加，生产技术的进步逐渐保证了共同体成员的日常消费，而且还出现了剩余。最初的剩余产品是属于共同体全体成员的，它可以用来同外族人交换急需的生产和生活物资，在更多的时候是用于举办宗教祭祀活动或公共庆典活动。共同体的首长在祭司和庆典活动中，主持对产品的再分配 这使他们赢得了更高的声望和威信。最初共同体首长和军事领袖的权利十分有限，他们是根据传统的习惯法选举产生的，在任职期间，他们的行为应符合共同体全体成员的利益，他们与全体成员一起从事生产，不能向他人索取任何礼物和赠品，不能强迫他人为自己劳动，如果他们的举止行为失当，就将被罢免。\n\n生产工具和技术的进步，使小规模生产成为可能，家族逐渐成为生产和生活单位，生产所得也归家族所有，这样私有制产生了。\n\n私有财产出现以及社会分工、血缘关系、人身依附、征服战争、移民和宗教活动等因素，直接导致聚落居民中，开始出现阶层和等级分化。高等级的人，在聚落的公共事务决策和宗教事务中拥有特权，在频繁的战争和冲突中，拥有强壮身体和军事能力的人，成为另一批有权势的人，他们共同组成了一个日益复杂的管理阶层，原始社会的社会组织管理职能也逐渐转变为带有强制力的政治权利。其他多数低等级的人成为被管理者，逐渐地，他们失去了在社会管理中的发言权，失去了自由获得财富的权力，失去了宗教权利，他们还要参加公共事业和战争，以此从管理者手中获得劳动报酬和维持生活的必需品。\n\n在人类文明早期的城市遗址中，出现了城墙、公共礼仪性建筑、手工业工场等等，社会的管理者逐渐演化为官吏阶层，形成了凌驾于社会之上的公共权力，原始形态的国家已经初具规模。\n\n#### 城市的产生\n\n**巴基斯坦**的考古学家在印度河流域发现了**哈拉帕**等城市遗址。公元前3500年左右，**苏美尔的乌鲁克**境内，已出现面积50公顷以上的中心城市。促成古代城市产生的另一个因素是举行政治、宗教活动的需要，这些建筑物成了政治、宗教活动的重心，也就是城市的中心 。几乎与城市出现的同时，作为文明诞生的文化体现，文字也萌生并逐渐成熟了。\n\n#### 文字\n\n从公元前4千年左右开始，两河流域的楔形文字、埃及的象形文字、印度河流域的印章铭文、中国的甲骨文和爱琴海区域的线形文字，依次被先民创造出来，人类由此掌握了知识的保存和传播技术。文明的曙光最先照耀在北纬20度到40度之间的农耕文明地带。约在公元前四千年代后期，西亚两河流域首先兴起了很多以城为中心的小国。稍后，北非的尼罗河流域、南亚的印度河流域、东亚黄河流域、南欧爱琴海区域等，也先后产生了国家，这些最早的文明中心宛如黎明破晓时的曙光，逐渐辉映着地球这颗蔚蓝色的星体，这成为地球乃至宇宙演化史上一道壮丽的历史景观，人类由此步入了最为辉煌的历史时代。","tags":["history"]},{"title":"添加新模块流程","url":"/2020/01/20/添加新模块流程/","content":"\n## web.xml filter struts2 过滤器  \n\n/WebContent/web.xml\n\n## structs-sample.xml 调用 action\n\n/src/structs-sample.xml  \n\n```xml\n<action name=\"deleteSample\" class=\"unit.tca.action.sample.DeleteSampleAction\">\n    <result name=\"success\" type=\"json\">\n        <params name=\"root\">success</params>\n    </result> \n</action>\n```\n\n## add java sourcecode\n\n/src/unit.tca.action.sample/DeleteLoadSampleAction.java  \n\n```java\npackage unit.tca.sample;\n\nimport java.io.Serialiable;\n\npublic class DeleteLoadSampleAction extends BaseAction{\n    private int id;\n    private boolean success;\n    public String execute(){\n        Session session = HibernateSessionFactory.getSession();\n        Transaction transaction = session.begingTransaction();\n        try{\n            try{\n                Sample sample=(Sample)session.get(Sample.class,Interger,valueOf(this.id));\n                session.delete((Object)sample);\n                transaction.commit();\n                this.success=true;\n            } catch (Exception e){\n                transaction.rollback();\n                e.printDtackTrace();\n                this.success=false;\n                HibernateSessionFactory.closeSession();\n            }\n        } finally {\n            HibernateSessionFactory.closeSession();\n        }\n        return \"success\";//接受字符串给jsp页面\n    }\n\n    public int getId(){\n        return id;\n    }\n    \n\n}\n```"},{"title":"java_web:xml","url":"/2020/01/20/java-web-xml/","content":"\n## xml 语法\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<a>a&lt;b</a>\n<!-- a<b &lt;\n    > &gt;\n    & &amp;\n    ' &apos;\n    \" &quot;\n    -->\n<![CDATA[内容]]>\n<!--\n    集体转义 \n    -->\n<?xml-stylesheet type=\"text/css\" href=\"css的路径\"?>\n<!--\n    更改样式\n    -->\n```\n\n\n## xml 约束方式\n\n### dtd 约束  \n\n``` xml\n<!--1.引入外部 -->\n<!DOCTYPE 根元素 SYSTEM \"dtd文件的路径\">\n<!--2.引入使用内部的dtd文件-->\n<!DOCTYPE 根元素 [\n<!ELEMENT person (name,age,hobby+)>\n<!ELEMENT name (#PCDATA)>\n<!ELEMENT age (#PCDATA)>\n]>\n<!--3.引入使用外部的dtd文件（网络上的dtd文件）-->\n<!DOCTYPE 根元素 PUBLIC \"DTD名称\" \"DTD文档的URL\">\n<!--后面学到框架 struts2 使用配置文件 使用 外部的dtd文件-->\n<!DOCTYPE struts PUBLIC   \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\" \"http://struts.apache.org/dtds/struts-2.0.dtd\">\n\n\n\n<!--dtd 文件本身 -->\n<!ELEMENT 元素名称 (子元素1|子元素2)>\n<!ELEMENT 元素名称 (#PCDATA)>  <!-- 约束是 PCDATA 或者 EMPTY 或者 ANY-->\n<!ATTLIST 元素名称 属性名称 属性类型 属性的约束> \n<!ATTLIST birthday ID1 CDATA #REQUIRED>  -- <birthday ID1=\"AAA\">2015</birthday>\n<!--属性类型是 CDATA 或者 ENUMERATED 或者 ID\n属性约束是 #REQUIRED(必须出现) #IMPLIED(可有可无) #FIXED(固定值)\n-->\n```\n\n### schema 约束\n\n\n\n## xml 解析方式\n\n1. dom 解析\n2. sax 解析\n\n对应常用解析器有: jaxp, dom4j(实际使用最多), jdom\n\n## 使用 jaxp api\n\njaxp 是 javase 的一部分 import javax.xml.parsers  \nDocumentBuilder  \n    new: DocumnentBuilderFactory.newDocumentBuilder()  \n    parse: Document parse(\"文档路径\") Document 是 org.w3c.dom下的接口  \n    取标签: Nodelist getElementByTag(String tagName) 遍历: i<list.getLength() list.iten(i)  \n    创建标签: createElement(String tagName)  \n    创建文本: creatTextNode(String data)  \n    文本添加到节点: appendChild(Node newChild) 或者删除 removeChild  \n    父节点: getParentNode()  \nDoucumentBuilderFactory  \n    new: newInstance()\n\n实现需求：查找name, 添加 node/删除/修改/遍历输出node名 \n1. 创建解析器工厂\n\n   ```java\n   DocumentBuildFactory builderFactory = DocumentBilderFactory.newInstance();\n   ```\n\n2. 通过工厂创建解析器\n   \n   ```java\n   DocumentBuilder builder = builderFactory.newDocumentBuilder();\n   ```\n\n3. 解析 xml 返回 document, 一定要回写，不然还在内存\n   \n   ```java\n   Document doc = builder.parse(\"src/person.xml\");\n   NodeList list = doc.getElementByTagName(\"name\");\n   for(int i=0;i<list.getLength();i++){\n       Node name = list.iten(i);\n       String s = name.getTextContent();//得到节点文本值 如果要修改，则是 setTextContent\n       System.out.println(s);\n   }\n   //添加\n   {\n   Element sex1 =document.createElement(\"sex\");\n   Text text = document.createTextNode(\"nv\");\n   sex1.appendChild(text);\n   p1.appendChild(sex1);\n   }\n   //递归遍历每一个节点\n   {\n       private static void list1(Node node){\n           if(node.getNodeType() == Node.ELEMENT_NODE){//避免空格换行都打印出来\n               Systom.out.println(node.getNodeName());\n           }\n           NodeList list = node.getChildNodes();\n           for(int i=0;i<node.getLength();i++){\n               Node node1 = node.items(i);\n               list1(node1);\n           }\n\n       }\n    }\n   //回写 xml\n   TransformerFactory tf = TransformerFactory.newInstance();\n   Transformer t = tf.newTransformer();\n   t.transform(new DOMSource(document),new StreamResult(\"src/person.xml\"))//transform(Source Node整个document父节点DocumentSource, Result StreamResult)\n   ``` \n"},{"title":"在Ubuntu上导入JavaWeb项目并配置","url":"/2020/01/19/在Ubuntu上导入JavaWeb项目并配置/","content":"\n## 准备ubuntu基本环境  \n\n1. 安装 JDK 任意版本  \n    一般安装在 /opt/java/ 解压  \n\n    ```bash\n    tar zvxf jdkxxxx /opt/java\n    ```\n\n    配置环境变量 /etc/profile  \n\n    ```bash\n    export JAVA_HOME=/opt/java/jdk1.8.0_181\n    export PATH=${JAVA_HOME}/bin:${PATH}\n    ```\n\n    使之生效\n\n    ```bash\n    source /etc/profile\n    ```\n\n    检查之  \n\n    ```bash\n    echo $JAVA_HOME\n    ```\n\n2. 安装 eclipse 任意版本  \n    一般安装在 /opt/eclipse/ 解压  \n\n    ```bash\n    tar zvxf eclipse-jeexxxx /opt/eclipse\n    ```\n\n    建立软连接，使 jre 成为其子目录  \n\n    ```bash\n    mkdir /opt/eclipse/jre\n    ln -s /opt/jvm/jdk1.8.0_181/bin /opt/eclipse/jre/\n    ```\n\n    添加 eclipse 桌面图标\n\n    ```bash\n    sudo gedit /usr/share/applications/eclipse.desktop\n    #打开文件后添加\n    [Desktop Entry]\n    Encoding=UTF-8\n    Name=Eclipse\n    Comment=Eclipse\n    Exec=/opt/eclipse/eclipse  #注意查看这两项实际地址与名称\n    Icon=/opt/eclipse/icon.xpm  #\n    Terminal=false\n    StartupNotify=true\n    Type=Application\n    Categories=Application;Development;\n    //赋予权限\n    sudo chmod u+x /usr/share/applications/eclipse.desktop\n    ```\n\n## 准备项目包  \n\n```bash\n#登录\nftp:192.168.1.185/Install/web/kingkong_web_ubuntu1404.tgz\nusername:tcauser\nuserpwd:tcasoft.com\n#解压到 /opt/\ntar zxvf kingkong_web_ubuntu1404.tgz /opt/\n#最后得到 /opt/kingkong_web/ 目录\n```\n\n## 配置eclipse环境\n\n1. 设置好工作空间  \n  一般也在 /opt/eclipse_workspace  \n2. 指定项目内的 jre 为新项目的 build path  \n  在 preference>Java>Installed JREs 中 add 路径为 /opt/kingkong_web/local/jdk1.7.xxxx\n3. 导入项目包  \n  import existing project into workspace  \n  选择目录为 /opt/kingkong_web/ 后 finish 导入  \n4. 设置项目内 tomcat 作为应用服务器  \n  打开 server view(windows>show views>server)  \n  新建 server, 选 tomcat 7.0 以及 /opt/kingkong_web/apache-tomcar-7.0.37, 将 KKWeb add 配置到上面 finish  \n\n## 配置环境变量以及启动 mysql/redis(实际上直接应用指令即可)\n\n1. 获取当前 user\n\n    ```bash\n    PROJ_USER=`whoami`\n    ```\n\n2. 获取 shell 文件所在 bin 父文件夹的绝对路径（即项目文件夹）  \n  \n    ```bash\n    # 获取当前执行 shell 文件所在路径及文件名\n    BASH_SOURCE  \n    BASH_SOURCE[0] # 输出为 /opt/kingkong_web/bin/noash_control\n    # 去除文件名，仅保留与目录有关部分\n    dirname\n    dirname \"$BASH_SOURCE[0]\" # 输出为 /opt/kingkong_web/bin\n    # 获取绝对路径名称\n    pwd\n    # 合\n    PROJ_DIR=`cd \"$(dirname $BASH_SOURCE[0])/..\"; pwd`\n    # 或者\n    PROJ_DIR=`cd \"`dirname $BASH_SOURCE[0]`/..\"; pwd`\n    ```\n\n3. 修改 PATH 可执行程序的查找路径  \n  \n    ```shell\n    #单次修改，关闭终端即无效\n    export PATH=\"/opt/kingkong_web/local/jdk1.7.0_80/bin:$PATH\" # 冒号是分隔符，表示在原有基础上添加\n    #稳定修改 ~/.bashrc 或者 ~/.bash_profile 或者系统级别的 /etc/profile 在其中添加\n    vi ~/.bashrc\n    source .bashrc\n\n    # 可执行文件添加 javahome/jrehome/classpath/javapath/pythonpath\n\n    export JAVA_HOME=\"$PROJ_DIR/local/jdk1.7.0_80\"\n    export PATH=\"$JAVA_HOME/bin:$PATH\"\n    export JRE_HOME=\"$PROJ_DIR/local/jdk1.7.0_80/jre\"\n    export CLASSPATH=\".:$JAVA_HOME/lib:$JRE_HOME/lib\" # 当前目录；jdklib；jrelib\n    export PYTHONPTH=\"$PROJ_DIR/local/lib/python2.7\"\n    ```\n\n    + 修改 LD_LIBRARY_PATH 动态库的查找路径  \n\n    ```bash\n    # 同样有命令单次和写文件两种\n\n    # 可执行文件添加 LD_LIBRARY/LIBRARY/C_INCLUDE/CPLUS_INCLUDE\n    export LD_LIBRARY_PATH=\"$PROJ_DIR/local/lib:$LD_LIBRARY_PATH\"\n    export LIBRARY_PATH=\"$PROJ_DIR/local/lib:$LIBRARY_PATH\"\n    export C_INCLUDE_PATH=\"$PROJ_DIR/local/include:$C_INCLUDE_PATH\"\n    export CPLUS_INCLUDE_PATH=\"$PROJ_DIR/local/include:$CPLUS_INCLUDE_PATH\"\n    LOG_FILE=\"$PROJ_DIR/log/apt.log\"\n    ```\n\n4. 根据start/stop/status运行响应配置程序\n\n    ```bash\n    case \"$1\" in # input argument[1]\n    start)\n        # 一般会重定向 1>/dev/null 2>&1\n        echo \"starting sandox-web cluster node ...\" >&2 # >&2 重定向到标准错误\n        start\n        echo \"started\" >&2\n        RETVAL=$? # 返回值为上一个函数\n    ;;\n\n    stop)\n        echo \"stop sandox-web cluster node ..\" >&2\n        stop\n        echo \"stoped\" >&2\n        RETVAL=$?\n    ;;\n\n    status)\n        status\n        RETVAL=$?\n    ;;\n\n    *)\n        echo \"Usage: bin/noah_control start/stop/status\" >&2\n        exit 1\n    ;;\n    esac\n\n    start() {\n        echo $PROJ_DIR\n        echo $PROJ_USER\n        #config mysql\n        cp $PROJ_DIR/mysql/my.cnf.apt $PROJ_DIR/mysql/my.cnf\n        sed -i \"s#apt_mysql_path#$PROJ_DIR#g\" $PROJ_DIR/mysql/my.cnf\n        ## 修改 opt/kingkong_web/mysql/my.cnf 中 apt_mysql_path 为 opt/kingkong_web\n        sed -i \"s#apt_mysql_user#$PROJ_USER#g\" $PROJ_DIR/mysql/my.cnf\n        ## 修改 opt/kingkong_web/mysql/my.cnf 中 apt_mysql_user 为 kk\n        #start mysql\n        cd $PROJ_DIR/mysql\n        nohup ./scripts/mysql_install_db --user=$PROJ_USER > $LOG_FILE &\n        ## nohup 表示 no hang up, 不被挂断，关闭 shell 仍能运行；& 表示后台运行，可以持续接受输入\n        ## 持续后台运行 mysql_install_db 参数为 --user=$PROJ_USER 输出重定向至 LOG 文件\n        nohup ./bin/mysqld_safe --defaults-file=$PROJ_DIR/mysql/my.cnf  &\n        #start redis\n        cd  $PROJ_DIR/redis\n        nohup ./redis-server redis.conf\n        cd $PROJ_DIR\n        #start tomcat\n        #nohup $PROJ_DIR/apache-tomcat-7.0.37/bin/startup.sh > $LOG_FILE &\n        sleep 3\n    }\n    # stop 和 status省略\n    ```\n\n## 在 eclipse 中启动 tomcat 即可/或者直接 start 中就可以\n\n/web/bin/noah_control start\n\n登录 localhost:8000/KKWeb/login/login.action  \n用户名：root  \n密码：root007\n\n## 需求\n\n动态分析下面加入二级菜单 同源分析  \n输入 md5/sha1/名称  \n查询  \n样本列表"},{"title":"Build and Maintain Hexo","url":"/2020/01/18/Build-and-Maintain-Hexo/","content":"> Editor notes: this tutorial is following official document in hexo  \n\n## installation  \n\ndependance:  \n\n+ Git  \n  \n  download from [Git Official](https://git-scm.com/)  \n\n    ```c\n    git config --global user.name \"Your Name\"\n    git config --global user.email \"email@example.com\" //configure your git repository  \n    ```\n\n+ Node.js  \n  \n  1. download packeage from [Nodejs Official Website](https://www.nodejs.org), follow install wizard  \n  2. check validation by cli:  \n\n    ```c\n    node -v //check version\n    npm -v //node package manager version\n    npm install -g cnpm --registry //globally registry to taobao mirror\n    cnpm -v //check cnpm version\n    ```\n\n+ Hexo  \n  \n  ```c\n  cnpm install -g hexo-cli\n  hexo -v //check validation\n  ```\n\n## initialization  \n\ninstall hexo-deployer-git:\n\n```shell\ncnpm install hexo-deployer-git --save\n\n```\n\n\nchange to desired directory(mkdir&cd)  \n\n```shell\nhexo init [folder]\nhexo s //start localhost:4000\nhexo n \"title\" //new a essay \nhexo g //generate\nhexo s //local check\n```\n\n## link to github  \n\n1. create a new repository named \"username.github.io\".  \n2. add text in _config.yml:\n\n    ```c\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n    type: git\n    repo: https://github.com/ToadYawn/toadyawn.github.io.git\n    branch: master\n    ```\n\n3. hexo command\n\n    ```c\n    hexo d //deploy to github\n    ```\n\n    input your github usermail and password\n\n\n## customize themes  \n\npreview themes in [ThemeWeb](https://hexo.io/themes)  \nclick picture to preview  \nclick link to github repository  \nclone to your local theme folder:  \n\n```c\ngit clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo\n```\n\nmodify your _config.yml:\n\n```c\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hipaper//chang here\n```\n\n```markdown\nFULL DOC:\n\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: ToadYawn\nsubtitle: 汤圆\nauthor: Tingyu Hu\nlanguage: zh\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://toadyawn.github.io\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n#Custom Setting Start\n\n# Site settings\n# 网站综合内容设置：\nSEOTitle: ToadYawn的博客 | ToadYawn's Blog\nemail: geisterwelt@163.com\ndescription: \nkeyword: \n\n# SNS settings\n# 一些社交平台地址，支持以下几种：\n# weibo_username:     \n# zhihu_username:     \ngithub_username: ToadYawn  \n# twitter_username:  \n# facebook_username:  \nlinkedin_username: tingyu-hu\n\n# Build settings\nanchorjs: true                          # if you want to customize anchor. check out line:181 of `post.html`\n\nsidebar-avatar: img/avatar.jpg \n    # use absolute URL, seeing it's used in both `/` and `/about/`\n\n# Friends\n# 友情链接\nfriends: [\n    {\n      title: \"It helps SEO\",\n      href: \"https://www.baidu.com\",\n    }\n]\n\n#comment:\n#  type: gitment\n#  id: your-id-created-by-https://github.com/settings/applications/new\n#  secret: your-secret-created-by-https://github.com/settings/applications/new\n#  owner: aircloud\n#  repo: hexo-aircloud-blog\n\n# comment:\n#    type: disqus\n#    script: 'https://airclouds-blog.disqus.com/embed.js'\n\n# donate:\n#   img: img/donate.jpg\n#   content: 感谢鼓励\n\n# The following content is not recommended to modify\n# 搜索数据文件路径设置，不建议改动：\nsearch:\n  path: search.json\n  field: post\n\n# 文章样式(是否首行缩进)：\npost_style:\n  indent: 0\n\n# Custom Setting End\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archive\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :year-:month-:day-:title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: true\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map: \n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 0\npagination_dir: page\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: aircloud\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n#  type: git\n#  repo: your repo url\n#  branch: master\n  type: git\n  repo: https://github.com/ToadYawn/toadyawn.github.io.git\n  branch: master\n\n\n```\n"},{"title":"Tomcat install & deploy web application","url":"/2020/01/14/javalearning/","content":"## directory of installed Tomcat  \n\n+ <kbd>bin</kbd> store script file for startup or shutdown in different operation system  \n+ <kbd>conf</kbd> configuration of tomcat including server.xml\n+ <kbd>lib</kbd> jar package needed by tomcat  \n+ <kbd>logs</kbd> log  \n+ <kbd>temp</kbd> Directory used by the JVM for temporary files (java.io.tmpdir)\n+ <kbd>webapps</kbd> java application accessible by client  \n+ <kbd>work</kbd> servlet files trasnformed from jsp \n\n\n## idea integrate tomcat  \n\ncreate new web application project  \nadd configuration  \nserver>local>tomcat directory"},{"title":"DigestWorldHistory001人类历史的开端——石器时代的人们","url":"/2020/01/12/history001/","content":"\n\n> 001人类历史的开端——石器时代的人们  \n\n## 人类的起源\n\n### 神创论或特创论：上帝造人\n\n基督教认为人类是上帝创造的。\n\n> And God said, Let us make man in our image, after our likeness: and let them have dominion over the fish of the sea, and over the fowl of the air, and over the cattle, and over all the earth, and over every creeping thing that creepeth upon the earth.  \n\n> 神就照着自己的形像造人，乃是照着他的形像造男造女\n\n圣经创世纪中上帝先用5天时间造昼夜、天地、植物、水生动物以及日月星辰，到了第六天用泥土造了一个叫亚当的男人，后来见亚当孤独又抽出他一根肋骨，变作一个叫夏娃的女子，与亚当结为美满夫妻。所以我们人类都是亚当和夏娃的子孙。\n\n之后引发一些有趣理论。厄谢尔，爱尔兰大主教，根据《圣经》的说法，推算出上帝造人的时间是公元前 4004 年。牛津大学圣约翰学院的神父，进一步把来当诞生的时间精确到小时，即公元前 4004 年 3 月 23 日上午 9 点整。\n\n### 自然发生说\n\n古希腊爱好智慧的哲学家，专注于仰观宇宙、俯察人生。  \n\n米利森学派的阿纳克西曼德断言，人是从海里的一种很像鱼的动物变化过来的，除开原始人的图腾崇拜，这是人类起源于动物界的最早说法。  \n神创论与自然发生说都是古人跟着感觉走而得出的假设，其中充满了孩童般的天真。 \n\n### 进化论\n\n18 世纪，现代生物学分类的鼻祖，瑞典植物学家**林奈**，在拟定动物分类系统时，将人和类人猿分到一起，通称为灵长类。  \n\n法国科学家**布丰**提出了人猿共祖的假设。由于处在基督教思想专政的末期，他的想法遭到《圣经》捍卫者们的围攻，在巴黎大学当众检讨才勉强过关，但他的思想影响了他的学生拉马克。  \n\n**拉马克**是进化论的伟大先驱，他于 1809 年发表《动物学哲学》一书，系统提出进化论的观点，这个理论的核心内容是**物种进化说**，认为一切生物都因自然的作用才得以产生，随着环境的变化而演化，开始简单、逐渐复杂。  \n\n英国生物学家**达尔文**（1809~1882） 1831 年底乘英国的贝格尔号参加了一次周游世界的考察，走了五年，到过美洲、澳大利亚，收集了很多的标本。1836 年 10 月回国以后用大约 20 年的时间，收集资料、潜心研究，于 1859 年发表了划时代的巨著《物种起源》。他指出：所有的动物和植物，都是自然界长期演化的产物，但没有涉及人类的进化问题。1871 年他出版了《人类的由来及其性选择》，第一次描述了人类进化地图景。  \n\n达尔文指出：\n\n> 在自然条件下，一切生物都要受周围环境的影响而发生变异，能够发生有利变异的物种就能生存和发展，不能发生有利变异的物种就必然被周围环境所淘汰。  \n\n这个基本原理在同时代清末被著名的启蒙思想家严复概括为八个字，叫作“物竞天择、适者生存”。  \n\n此时在西方，达尔文的理论提出的时候，遭到教会的猛烈反对，在社会上也引起广泛的争论。然而，随着科学的进步，在其晚年时，学术界已经不再怀疑进化论了。  \n\n### 人类祖先遗迹的发现  \n\n进化论确立之前，考古学家和古生物学家已经发现许多古人化石以及伴生的打制石器及其它工艺品。但在进化论确立之前，人们还想像不到在亚当夏娃出现之前会有人类存在，所以他们无法理解这些发现的含义。进化论确立之后，欧洲知识分子的目光越出了教会划定的界限，开始到世界各地寻找远古人类的痕迹，陆续成功的发现大量古人类的化石与他们使用的工具。\n\n地球上最早的人类化石：*能人 非洲坦桑尼亚 奥杜威峡谷*  \n发现者：*英国古人类学家利基夫妇利基*  \n\n在剑桥大学完成非洲史前史学业后，一心到东非去寻找古人类化石。在 20 世纪前半期，有关早期人类的大发现都集中在亚洲，比如印尼的爪哇人、中国的北京人，但是利基却执意要去非洲，利基夫妇在媾锲而不舍的工作了几十年，终于在 1961 年发现了最早的人类遗存，定年在 170 至 190 万年前。  \n\n>在能人之前还有更早的人类祖先南方古猿，南方古猿是在上个世纪七十年代以来陆续发现的一组变异很大的化石，存在的时间大概从五百多万年前到一百万年前。这些化石的发现具有很大的意义，因为在此以前，人们普遍认为，人类的两个基本的特征就是直立行走和制造工具，这两个特征是同时出现的。然而，南方古猿的发现推翻了这个结论。南方古猿普遍能够直立行走，但不会制造工具，有关这方面的最直接的证据就是利基夫人在 1976 年于坦桑尼亚奥杜威峡谷以南的一个叫作莱托利的平原上发现的两个南方古猿个体的脚印。莱托利平原上有一座火山，火山曾经喷发过，在它的周围形成了很厚的火山灰的沉积层。考古队员们有一次在打闹当中，用大象粪互相击打，有一个队员倒地后发现火山灰的凝结层当中有动物的脚印痕迹，考古队员们就顺着这个痕迹挖了下去，挖出了一条几十米长的脚印带。在脚印带当中，有两个南方古猿个体的脚印，一个是成年的、一个是小孩的，在它们脚印周围还有许多动物的脚印，所有这些脚印都显得从容不迫，看来它们已经对火山的喷发司空见惯了。  \n（北京师范大学历史学院教授郭小凌）  \n\n### 石器时代  \n\n从能人开始，世界历史进入了它的最初阶段-石器时代。\n\n石器是人类祖先生存斗争的基本武器，根据工具制作技术的不同，石器时代又分成旧石器时代和新石器时代两大阶段，两大阶段之间插着一个过渡阶段，人称中石器或细石器时代。  \n\n旧石器是指打制的石器，石器时代当中以旧石器时代时间是从 180 万年前一直延续到约 15000 年前，由于时间久远，考古学家为了认识的方便起见，又把这个时期分成三个较短的时期：即旧石器时代早期、中期和晚期。  \n\n#### 旧石器时代早期  \n\n旧石器时代早期自 180 万年前至 20~30 万年前。这个时期的人类还带有猿的特征，所以被称为猿人。比如最早的能人脑量不只有 500 至 700 亳升，身高在 1.2 至 1.4 米、能直立行走。较晚期的猿人，如非洲的奥科托姆人欧洲的海德堡人、亚洲的北京人、蓝田人等，脑量虽然增大到 750 至 1059 毫升，身高增长到 1.6 米左右，但还是同现代人有显著的区别。尤其头骨构造仍具有猿的特征，吻部、眉脊突出、前额矮平、没有或只有很小的下颌。猿人的食物来源要靠采集和狩猎。他们采集和狩猎的工具主要是用砾石相互敲打成多面体、棱锥体、石片之类的敲砸器。他们用这些粗糙的工具刺杀、猎捕、切割性情比较温和的大中型动物，如长颈鹿、野马、大象、河马、羚羊等等。至于鸟类、鱼类、昆虫、鸟蛋、植物块根果实甚至昆虫就更是早期人类的果腹之物了。\n\n##### 1. 生产工具  \n   随着上百万年生存经验的积累，旧石器早期的人们逐渐能按照自己的预想去生产自己的产品，于是出现多用途的石器，像两面打击成型的手斧、砍砸器、刮削器、尖状器之类。  \n\n##### 2. 人工用火\n   在100多万年前至50万年前这段时间里，世界一些地区的古人类相继掌握了人工控制天然火的技能。考古学家分别在肯尼亚的切期旺贾以及我国山西芮城西候度、北京周口店猿人遗址发现了人工用火的痕迹。  \n   \n   火的使用在世界史上具有划时代的意义，无论怎样估量都不过分。火被用来加工食物、取暖以及自我保护，烧制的食物不仅味道好、而且易于咀嚼和消化。高温加热的食物可以形成200多种新的化合物，促使人体内脏、大脑、骨骼、口腔的进化加快。  \n   \n   火还被用来驱赶野兽、加工木器，导致人类猎取动物的水平空前提高，披毛犀、野牛、剑齿象这些大型野兽也就成了原始人的猎物。更重要的是，有了火人类从此有再风餐露宿，迁入了可以遮风避雨的洞穴。这样在100万年前开始的四次大冰期当中，人类不仅在北半球的冰天雪地中生存下来，而且还迁徙到了旧大陆的大部分地区。  \n\n>至于他们的社会结构，公社的领袖通常是由公社的成员集体推选产生的，在氏族和部落阶段，公社还实行严格的外婚制，公社内部的成员必须到公社外部去寻找自己的配偶。  \n公社内实行严格的社会分工，比如说男人出去狩猎，女人在驻地照料孩子和采集各种野生植物。  \n（北京师范大学历史学院教授郭小凌）  \n\n##### 3. 分节语\n   北京猿人的颅骨内腔结构证实，人类的分节语能力产生于旧石器时代早期约50万年前左右，与人工用火的发明在同一时期。  \n\n#### 旧石器时代中期  \n\n时钟转到大约25万年前，也就是到了旧石器时代中期，人类开始从猿人阶段向我们现代人过渡。  \n\n##### 身体的变化\n\n>直立行走实际上不仅仅是解放了人的双手，而且它还引起了身体部位的某些相关的变化。  \n具体到发音器官上，随着人的直立行走和腭部的隆起，人的吻部会萎缩，口腔和喉会形成一个直角，这个直角是人类区别于其它动物的地方之一，非常有利于发出各种各样的声音。另外，从当时人类的情况来看，熟食的发明使得人类的咀嚼器官逐渐萎缩、牙床变小，口腔内发音器官的活动余地变得更大，这样非常有利于人类语言当中的共鸣和唇音的形成。  \n（北京师范大学历史学院教授郭小凌）  \n\n#### 旧石器时代晚期\n\n大约5万年前，人类进入了旧石器时代晚期。这时的人在体质形态方面已经同我们现代人没有什么差别，三大人种的形成过程也已完结。\n\n> 现代人类学认为，人种或者叫作种族是具有遗传特征的人类群体，大体分成三类：第一类是蒙古利亚人种，也叫黄种人；第二类是高加索人种，也叫白种人；第三类是尼格罗人种，也叫黑种人。黄种人主要分布在亚洲，白种人主要分布在欧美，黑种人主要分布在撒哈拉沙漠以南的非洲。  \n各人种之间体质形态的差别主要表现在四个方面：皮肤的颜色、眼睛的颜色、头发的颜色和体形。  \n这些不同的特征是受不同的地理环境影响形成的比如说黑人大多数皮肤黝黑是因为这种黝黑的皮肤用于保护身体免受紫外线的伤害。大多数黑人的头发是卷曲的。是因为这种卷曲的发型可以提高身体的隔热性。再比如北部欧洲的白人大多数，鼻梁隆起、鼻腔狭长，是因为这种鼻型用于空气的加热。这些现象、特征进一步证明人类的体质是受到不同的地理环境的影响、逐渐地演变成的。但是这与智力品格方面的高低优劣没有什么关系。  \n（北京师范大学历史学院教授郭小凌）  \n\n到了旧石器时代的晚期，石器制作的技术又有了很大的发展，像当时出现的间接打击法、钻孔法和摩擦法等等。  \n\n随着人类生存能力不断提高，人类的活动空间明显扩大，人类在晚期智人时代跨过白令海峡、飘过太平洋岛屿、成群结队在美洲和大洋洲安家落户。所以，第一批发现新大陆的移民，与其说是近代欧洲人，不如说是旧石器时代的亚洲居民。  \n\n物质生活的改变伴随着精神生活的进步，在旧石器时代的尾声中，人类的语言随着人类分散到世界各地而分化成几千种语音、词汇和语法结构不同的分节语。  \n\n只要有人存在，就能找到各种原始宗教的痕迹，如图腾崇拜、安灵崇拜、祖先崇拜等，以及以洞穴壁画和雕刻为代表的丰富多彩的原始艺术。这些岩画描绘出表达他们喜怒哀乐的情调。这些早期人类的绘画是文字长期发展历史中的第一步，正是这种技艺把我们与地球上其他生物区别开来，并为我们提供一个保存历史的方法。它意味着那史无前例无比瑰丽的文明社会的曙光就要升起在地平线之上了。","tags":["history"]}]